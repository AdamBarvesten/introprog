\documentclass[article, a5paper]{memoir}

\let\footruleskip\undefined\usepackage{fancyhdr}% http://ctan.org/pkg/fancyhdr

\usepackage{pgfpages}
\pgfpagesuselayout{resize to}[a4paper]

% Swedish.
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage[swedish]{babel}
\usepackage{microtype}

%%% FONT PACKAGES
%\usepackage[sc]{mathpazo}
%\usepackage[varg]{txfonts}
%\usepackage{times}
%\usepackage{tgtermes}% clone of times
%\usepackage[sfdefault,condensed]{cabin}
\usepackage{PTSansNarrow}\renewcommand*\familydefault{\sfdefault}
%\usepackage{tgcursor}
\usepackage[scaled=0.85]{beramono} % inconsolata or beramono ???
%\usepackage{fouriernc} % serif: new century schoolbook
%\usepackage{avant}     % sans serif: Avant Garde


% Typeblock size, margins.
\settypeblocksize{190mm}{127mm}{*}
\setlrmargins{10.5mm}{*}{*}
\setulmargins{10.0mm}{*}{*}
\setheadfoot{0.1pt}{0.1pt}
\checkandfixthelayout
\usepackage{multicol} \setlength{\columnsep}{5mm}
\usepackage{xcolor}
\usepackage{array}

\definecolor{mygreen}{rgb}{0,0.4,0}
\definecolor{grammarcolor}{rgb}{0.3,0.6,0.1}
\definecolor{mylinkcolor}{rgb}{0,0.1,0.5}
\definecolor{myemphcolor}{rgb}{0,0.4,0.1}
\definecolor{myalertcolor}{rgb}{0.4,0.1,0}
\definecolor{eclipsepurple}{rgb}{0.5,0,0.25}
\definecolor{eclipseblue}{rgb}{0.16,0,1.0}
\definecolor{eclipsegreen}{rgb}{0,0.5,0}


\newcommand{\OptL}{\textbf{\textcolor{grammarcolor}{[}}}
\newcommand{\OptR}{\textbf{\textcolor{grammarcolor}{]}}}
\newcommand{\RepL}{\textbf{\textcolor{grammarcolor}{(}}}
\newcommand{\RepR}{\textbf{\textcolor{grammarcolor}{)}}}
\newcommand{\Or}{\textbf{\textcolor{grammarcolor}{|}}}

%---------------------------------------------------------------

\newcommand{\LangColor}{red}

\setlength{\parindent}{0pt}
\raggedright
\raggedbottom
\linespread{0.90}\selectfont
\pagestyle{empty}

\newcommand{\mc}[1]{\multicolumn{2}{l}{\hspace{-0.65em}\parbox[t]{102mm}{\small #1}}}

\newcommand{\ind}{\hspace*{1.5em}}

\newcommand{\head}[1]{{\bfseries {\color{\LangColor}{#1}}\par\vspace{1mm}\hrule\vspace{-2mm}}}

\newenvironment{etab}%
{\begin{ctabular}{@{}>{\raggedright\small}p{25mm} @{}>{\raggedright\small}p{45mm} @{}>{\raggedright\arraybackslash\small}p{57mm}}}
{\end{ctabular}}%


\newcommand{\secend}{\\[1mm]}
\newcommand{\subsecend}{\\ \\[-2mm]}
\renewcommand{\arraystretch}{0.9}

% -----------
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{shapes.geometric, shapes.symbols, arrows, matrix, shapes, positioning}
%https://www.sharelatex.com/blog/2013/08/29/tikz-series-pt3.html
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=1cm, minimum height=1cm, text=white, text centered, draw=black, fill=blue!50!violet]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text=white, text centered, draw=black, fill=red!50!black]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]
%UML definitions
\tikzstyle{umlclass}=[rectangle, draw=black,  thick, anchor=north, text width=3cm, rectangle split, rectangle split parts = 3]
\tikzstyle{umlarrow}=[->, >=open triangle 90, thick]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% lingstings specifics:
\usepackage{listings}
\usepackage{upquote} %http://tex.stackexchange.com/questions/145416/how-to-have-straight-single-quotes-in-lstlistings
\lstdefinelanguage{Scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,forSome,if,implicit,import,lazy,match,%
    new,null,object,override,package,%
    private,protected,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}


\lstset{
    language=Scala,
    tabsize=2,
    basicstyle=\ttfamily\selectfont,
    keywordstyle=\bfseries\textcolor{eclipsepurple},
    commentstyle=\textcolor{mygreen},
    numberstyle={\footnotesize},
    numbers=none,
    %backgroundcolor=\textcolor{gray!15},
    frame=none,
    rulecolor=\color{black!25},
    %title={\footnotesize\lstname},
    breaklines=false,
    breakatwhitespace=false,
    framextopmargin=2pt,
    framexbottommargin=2pt,
    showstringspaces=false,
    columns=fullflexible,keepspaces
}
\lstset{literate=%
{Å}{{\AA}}1
{Ä}{{\"A}}1
{Ö}{{\"O}}1
{Ü}{{\"U}}1
{ß}{{\ss}}1
{ü}{{\"u}}1
{å}{{\aa}}1
{ä}{{\"a}}1
{ö}{{\"o}}1
{æ}{{\ae}}1
{ø}{{\o}}1
{Æ}{{\AE}}1
{Ø}{{\O}}1
{`}{{\`{}}}1
{─}{{\textemdash}}1
{└}{{|}}1
{├}{{|}}1
{│}{{|}}1
}

\newcommand{\code}{\lstinline[basicstyle=\ttfamily]}
\newcommand{\jcode}{\lstinline[basicstyle=\ttfamily,language=Java]}

\lstnewenvironment{Code}[1][]{%
    \lstset{basicstyle=\ttfamily\fontsize{10}{12}\selectfont,#1}%
}{}

%*****************************************************************



\newcommand{\LangRect}[4]{\tikz[overlay, remember picture,inner sep=7pt,minimum height=0.65cm] \node[fill=#2,text=white,rotate=90] at #4 (name) {\large\normalfont\textbf{#1} ~~{\small \thepage(4)}}; }  

\newcommand{\LangRectOdd}[3]{\LangRect{#1}{#2}{#3}{($(current page.north east)-(0.35,#3)$)}}  
\newcommand{\LangRectEven}[3]{\LangRect{#1}{#2}{#3}{($(current page.north west)-(-0.35,#3)$)}}  
    

\newcommand{\LangMarker}[2]{%param 1 = language, param 2 = offset from top
%\fancyhead{} % clear all header fields
\fancyfoot{} % clear all footer fields
%\fancyfoot[RO]{\thepage}
%\fancyfoot[LE]{\thepage}
\fancyhead{
\ifodd\thepage\LangRectOdd{#1}{\LangColor}{#2}
\else\LangRectEven{#1}{\LangColor}{#2}
\fi
}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\pagestyle{fancy}
}

\newcommand{\Newline}{\vspace{\baselineskip}}

\newcommand{\LangTitle}[1]{{\centering \Huge{\bfseries\sffamily \color{\LangColor}{#1}}\par\Newline}}



\begin{document}

\LangMarker{Scala}{1.5cm}
\LangTitle{Scala Quick Reference}

blablabla

\Newline
\head{Expressions}
\begin{etab}
Arithmetiskt uttryck & (x + 2) * i / 3          &  skrivs som i matematiken, för heltal är / \\
                  &                            &  heltalsdivision, \% ''rest'' \secend
\end{etab}

\vspace{\baselineskip}
Hello \code{if}  \jcode{if}

\head{Control structures}

\vspace{\baselineskip}
Hello \code{if}  \jcode{if}
\clearpage


\clearpage




\head{Type system}\Newline
Scala's type hierarchy 
\includegraphics[width=1.0\textwidth]{../img/hierarchy.pdf}

\Newline

{\small \renewcommand{\arraystretch}{1.2}
\begin{tabular}{p{2.8cm}   l l l l}
Size of basic types
& \textbf{name} & \textbf{\# bits} & \textbf{range} & \textbf{JVM}\\ \cline{2-5} %\hline 
\\[-1em]
&\texttt{Byte}   &  8  & $-2^7$ ... $2^7-1$   & \texttt{byte} \\
&\texttt{Short}  &  16 & $-2^{15}$ ... $2^{15}-1$ & \texttt{short} \\
&\texttt{Char}   &  16 & $0$ ... $2^{16}-1$ & \texttt{char} \\
&\texttt{Int}    &  32 & $-2^{15}$ ... $2^{15}-1$ & \texttt{int} \\
&\texttt{Long}   &  64 & $-2^{15}$ ... $2^{15}-1$ & \texttt{long} \\
&\texttt{Float}  &  32 & ± $3.4028235 \cdot 10^{38}$  & \texttt{float} \\
&\texttt{Double} &  64 & ± $1.7976931348623157 \cdot 10^{308}$ & \texttt{double} \\
\end{tabular}
}

\Newline\head{Collections}
{
\small\renewcommand{\arraystretch}{1.25}
\begin{multicols}{2}
\texttt{scala.collection.}
\begin{tabular}{l l l}
\texttt{immutable.} & \texttt{mutable.} & methods with good performance: \\
\hline
\texttt{Vector} & \texttt{ArrayBuffer} & \texttt{head tail apply +: :+}\\
\texttt{List} &  \texttt{ListBuffer} &  \texttt{head +:}  \\
\texttt{Set} & \texttt{Set} & \texttt{contains~~+~~-}\\
\texttt{Map} & \texttt{Map} & \texttt{apply~~+~~-} \\
\end{tabular}

\vspace{0.5em}

\texttt{String} and \texttt{Array} are implicit subtypes of \texttt{Seq}\\ making sequence methods work as for other collections. 


\columnbreak

\newcommand{\NodeSkip}{0.5cm}
\begin{center}
\tikzstyle{collectiontype}=[rectangle, draw=black,  thick, anchor=north, text width=1.7cm, rectangle split, rectangle split parts = 1]
\begin{tikzpicture}[node distance = \NodeSkip]
\node (Traversable) [collectiontype]  {\texttt{\centerline{Traversable}}};
\node (Iterable) [collectiontype, below = of Traversable]  {\texttt{\centerline{Iterable}}};        
\node (Seq) [collectiontype, below left = \NodeSkip and 0.05cm of Iterable,text width=1.0cm,]  {\texttt{\centerline{Seq}}}; 
\node (Set) [collectiontype, right = of Seq, text width=1.0cm,]  {\texttt{\centerline{Set}}};               
\node (Map) [collectiontype, right = of Set, text width=1.0cm,]  {\texttt{\centerline{Map}}};        
\node (Vector) [collectiontype, below left = \NodeSkip and -0.3cm of Seq, text width=1.0cm,]  {\texttt{\centerline{Vector}}};     
\node (List) [collectiontype, below right = \NodeSkip and -0.2cm of Seq, text width=1.0cm,]  {\texttt{\centerline{List}}};              
      
\draw[umlarrow] (Iterable.north) -- (Traversable.south);        
\draw[umlarrow] (Seq.north) -- (Iterable.south west);        
\draw[umlarrow] (Set.north) -- (Iterable.south);        
\draw[umlarrow] (Map.north) -- (Iterable.south east);        
\draw[umlarrow] (Vector.north) -- (Seq.south west);        
\draw[umlarrow] (List.north) -- (Seq.south east);        
\end{tikzpicture}
\end{center}
\end{multicols}
}
\clearpage

\head{Operations in trait \texttt{Traversable}}\Newline

{\small\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l p{3.4cm} p{6.6cm}}
\textbf{What} & \textbf{Example} & \textbf{Explanation} \texttt{f} is function, \texttt{pf} is partial funct., \texttt{p} is predicate.\\ \hline
Traverse: & \texttt{xs foreach f} & Executes f for every element of xs. Returntype \texttt{Unit}.\\ \cline{1-3}

  Add: & \texttt{xs ++ ys} & A collection with xs followed by ys.\\\cline{1-3}
  
  Map: & \texttt{xs map f} & A collection formed by applying f to every element in xs.\\ \cline{2-3}
       & \texttt{xs flatMap f} & A collection obtained by applying f (which must return a collection) to all elements in xs and concatenating the results.\\ \cline{2-3}
       & \texttt{xs collect pf} & The collection obtained by applying the pf to every element in xs for which it is defined (undefined ignored).\\ \cline{1-3}

  Convert: & \texttt{toVector toList toSeq toBuffer toArray} & Converts a collection. Unchanged if the run-time type already matches the demanded type.\\ \cline{2-3}
   & \texttt{toSet} & Converts the collection to a set; duplicates removed.\\ \cline{2-3}
   & \texttt{toMap} & Converts a collection of key/value pairs to a map. \\ \cline{1-3}

  Copy: & \texttt{xs copyToBuffer buf } & Copies all elements of xs to buffer buf. Returntype \texttt{Unit}\\ \cline{2-3}
   & \texttt{xs copyToArray (arr, s, n)} & Copies at most n elements of the collection to array arr starting at index s (last two arguments are optional). Returntype \texttt{Unit}\\ \cline{1-3}

  Size info: & \texttt{xs.isEmpty} & Returns true if the collection xs is empty.\\ \cline{2-3}
   & \texttt{xs.nonEmpty} & Returns true if the collection xs has at least one element.\\ \cline{2-3}
   & \texttt{xs.size} & Returns an \texttt{Int} with the number of elements in xs.\\ \cline{1-3}
   

  Retrieval: & \texttt{xs.head \newline xs.last} &  	The first/last element of xs (or, some element, if no order is defined).\\ \cline{2-3}
      & \texttt{xs.headOption \newline xs.lastOption} & The first/last element of xs (or, some element, if no order is defined) in an option value, or \texttt{None} if xs is empty.\\ \cline{2-3}
      & \texttt{xs find p} & An option with the first element satisfying p, or None.\\ \cline{1-3}


  Subparts: & \texttt{xs.tail xs.init} & The rest of the collection except xs.head or xs.last.\\ \cline{2-3}
      & \texttt{xs slice (from, to)} & The elements in from index \texttt{from} until (not including) \texttt{to}.\\ \cline{2-3}
      & \texttt{xs take n} & The first n elements (or some n elements, if order undefined).\\ \cline{2-3}
      & \texttt{xs drop n} & The rest of the collection except xs take n.\\ \cline{2-3}
      & \texttt{xs takeWhile p} & The longest prefix of elements all satisfying p.\\ \cline{2-3}
      & \texttt{xs dropWhile p} & Without the longest prefix of elements that all satisfy p.\\ \cline{2-3}
      & \texttt{xs filter p} & Those elements of xs that satisfy the predicate p. \\ \cline{2-3}
      & \texttt{xs filterNot p} & Those elements of xs that do not satisfy the predicate p.\\ \cline{2-3}
      & \texttt{xs splitAt n} &  	Split xs at n returning the pair (xs take n, xs drop n).\\ \cline{2-3}
      & \texttt{xs span p} & Split xs by p into the pair (xs takeWhile p, xs.dropWhile p).\\ \cline{2-3}
      & \texttt{xs partition p} & Split xs by p into the pair (xs filter p, xs.filterNot p)\\ \cline{2-3}
      & \texttt{xs groupBy f} & Partition xs into a map of collections according to f.\\ \cline{1-3}


  Conditions: & \texttt{xs forall p} & xxx\\ \cline{2-3}
      & \texttt{xs exists p} & xxx\\ \cline{2-3}
      & \texttt{xs count p} & xxx\\ \cline{1-3}

  Folds: & \texttt{xs.foldLeft(z)(op) xs.foldRight(z)(op)} & Apply binary operation op between successive elements of xs, going left to right (or right to left) starting with z.\\ \cline{2-3}
      & \texttt{xs reduceLeft op \newline xs reduceRight op} & Same as foldLeft/foldRight, but xs must be non-empty, starting with first element instead of z.\\ \cline{2-3}
      & \texttt{xs.sum xs.product xs.min xs.max} & Calculation of the sum/product/min/max of the elements of xs, which must be numeric.\\ \cline{1-3}
                              
   Make string: & \texttt{xs mkString (start, sep, end)} & A string with all elements of xs between separators sep enclosed in strings start and end; start, sep, end are all optional.\\ \cline{1-3}

   
\end{tabular}
}

\clearpage

\head{Operations in trait \texttt{Iterable}}\Newline

{\small\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l p{3.4cm} p{6.6cm}}

\textbf{What} & \textbf{Example} & \textbf{Explanation} \texttt{f} is function, \texttt{pf} is partial funct., \texttt{p} is predicate.\\ \hline

  XXX: & \texttt{xxx} & xxx\\   \cline{2-3}

   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{1-3}

  XXX: & \texttt{xxx} & xxx\\   \cline{2-3}

   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{1-3}
        
\end{tabular}
}  

\Newline
\head{Operations in trait \texttt{Seq}}\Newline

{\small\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l p{3.4cm} p{6.6cm}}

\textbf{What} & \textbf{Example} & \textbf{Explanation} \texttt{f} is function, \texttt{pf} is partial funct., \texttt{p} is predicate.\\ \hline

  XXX: & \texttt{xxx} & xxx\\   \cline{2-3}

   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{1-3}

  XXX: & \texttt{xxx} & xxx\\   \cline{2-3}

   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{1-3}
        
\end{tabular}
}  


\Newline
\head{Operations in trait \texttt{Set}}\Newline

{\small\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l p{3.4cm} p{6.6cm}}

\textbf{What} & \textbf{Example} & \textbf{Explanation} \texttt{f} is function, \texttt{pf} is partial funct., \texttt{p} is predicate.\\ \hline

  XXX: & \texttt{xxx} & xxx\\   \cline{2-3}

   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{1-3}

  XXX: & \texttt{xxx} & xxx\\   \cline{2-3}

   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{2-3}
   & \texttt{xxx} & xxx\\\cline{1-3}
        
\end{tabular}
}  

\Newline\head{Reserved words}\Newline

{\small The 40 words and 10 symbols below have special meaning and cannot be used as identifiers in Scala.}
 
\begin{Code}[morekeywords={macro,\_},otherkeywords={>,<-,\%,<,>:,@,:,=,\#}]
abstract case catch class def do else extends false final 
finally for forSome if implicit import lazy macro match new 
null object override package private protected return sealed 
super this throw trait try true type val var while with yield 
_ : = => <- <: <% >: # @ 
\end{Code}




\clearpage
\setcounter{page}{1}
\renewcommand{\LangColor}{blue}
\LangMarker{Java}{3.5cm}

\LangTitle{Java snabbreferens}

{\small Tecknet ~\Or~ står för ''eller''. Vanliga parenteser \RepL \RepR ~används för att gruppera alternativ. Med \OptL \OptR ~markeras sådant som inte alltid finns med. Med \jcode{stmt} avses en sats, \jcode{x}, \jcode{i}, \jcode{s}, \jcode{ch} är variabler, \jcode{expr} är ett uttryck, \jcode{cond} är ett logiskt uttryck.}

\Newline
\head{Satser}

\begin{etab}
Block   & \jcode|{stmt1; stmt2; ...}| &  fungerar ''utifrån'' som \textbf{en} sats \secend

Tilldelningssats & \jcode|x = expr;|                 &  variabeln och uttrycket av kompatibel typ \secend

Förkortade       & \jcode|x += expr; |                &  x = x + expr; även --=, *=, /= \\
                 & \jcode|x++;  |                     &  x = x + 1; även x\hspace{0.5mm}-- -- \secend

if-sats          & \jcode|if (cond) {stmt; ...}|      &  utförs om cond är true \\
                 & \OptL \jcode|else { stmt; ...}| \OptR&  utförs om false \secend

switch-sats      & \jcode|switch (expr) {|         &  expr är ett heltalsuttryck \\ 
                 & \jcode|    case A: stmt1; break;|  &  utförs om expr $=$ A (A konstant) \\
                 & \jcode|    ...|                 & \\
                 & \jcode|    default: stmtN; break;| &  utförs om inget case passar\\
                 & \jcode|}|                   & \secend

for-sats         & \jcode|for (int i = start; i < stop; i++) {| & \\
                 & \jcode|    stmt;|  & satserna utförs för i = start, start+1, \ldots, stop$-1$ \\
                 & \jcode|    ...;|         &  (ingen gång om start >= stop) \\
                 & \jcode|}|                &  i++ kan ersättas med i = i + step \secend

while-sats       & \jcode|while (cond) {|          & \\
                 & \jcode|    stmt; ...|           &  utförs så länge cond är true \\
                 & \jcode|}|                       & \secend

do-while-sats    & \jcode|do {|                     & \\
                 & \jcode|    stmt; ...|         &  utförs minst en gång, \\
                 & \jcode|} while (cond);|          &  så länge cond är true \secend

return-sats      & \jcode|return expr;|        &  returnerar funktionsresultat
\end{etab}

\head{Uttryck}
\begin{etab}
Aritmetiskt uttryck & (x + 2) * i / 3          &  skrivs som i matematiken, för heltal är / \\
                  &                            &  heltalsdivision, \% ''rest'' \secend

Objektuttryck     & \mc{new Classname(\ldots) | ref-var | null | function-call | this | super} \secend

Logiskt uttryck   & \mc{! log-expr | log-expr \&\& log-expr | log-expr || log-expr | function-call | relation | log-var | true | false} \subsecend

Relation          & \mc{ expr ( < | <= | == | >= | > | != ) expr (för objektuttryck bara == och !=, också expr instanceof Classname)} \subsecend

Funktionsanrop    & obj-expr.method(\ldots)    &  anropa ''vanlig metod'' (utför operation) \\
                  & Classname.method(\ldots)   &  anropa statisk metod \secend

Vektor (array)    & new int[size]              &  skapar int-vektor med size element \\
                  & vname[i]                   &  elementet med index i, 0..length$-1$\\
                  & vname.length               &  antalet element \secend

Typkonvertering   & (newtype) expr             &  konverterar expr till typen newtype \\
                  & (int) real-expr            &  -- avkortar genom att stryka decimaler \\
                  & (Square) aShape            &  -- ger ClassCastException om aShape inte \\
                  &                            &  är ett Square-objekt
\end{etab}

\clearpage 
\head{Deklarationer}
\begin{etab}
Allmänt           & \mc{[<protection>] [static] [final] <type> name1, name2, \ldots;} \secend

<type>            & \mc{byte | short | int | long | float | double | boolean | char | Classname} \secend

<protection>      & public | private | protected &  för attribut och metoder i klasser \\
                  &                             &  (paketskydd om inget anges) \secend

Startvärde        & int x = 5;                  &  startvärde bör alltid anges \secend

Konstant          & final int N = 20;           &  konstantnamn med stora bokstäver \secend

Vektor            & <type>[\hspace{0.4mm}] vname = new <type>[10]; &  deklarerar och skapar vektor
\end{etab}


\head{Klasser}
\begin{etab}
Deklaration       & [public][abstract] class Classname & \\
                  & \mc{\ind [extends Classname1] [implements Interface1, Interface2, \ldots] $\{$} \\
                  & \ind <deklaration av attribut> & \\
                  & \ind <deklaration av konstruktorer> & \\
                  & \ind <deklaration av metoder> & \\
                  & $\}$                          & \secend

Attribut          & \mc{Som vanliga deklarationer. Attribut får implicita startvärden, 0, 0.0, false, null.} \secend

Konstruktor       & <prot> Classname(param, \ldots) $\{$ &  Parametrarna är de parametrar som ges vid \\
                  & \ind stmt; \ldots              &  new Classname(\ldots). Satserna ska ge \\ 
                  & $\}$                           &  attributen startvärden \secend

Metod             & <prot> <type> name(param, \ldots) $\{$ &  om typen inte är void måste en return-\\
                  & \ind stmt; \ldots              &  sats exekveras i metoden \\
                  & $\}$                           & \secend
                  
Huvudprogram      & \mc{public static void main(String[\hspace{0.5mm}] args) $\{$ \ldots $\}$} \secend

Abstrakt metod    & \mc{Som vanlig metod, men abstract före typnamnet och $\{\ldots\}$ ersätts med semikolon. Metoden måste implementeras i subklasserna.}
\end{etab}

\head{Standardklasser, java.lang, behöver inte importeras}
\begin{etab}
Object            & \mc{Superklass till alla klasser.} \subsecend
                  & boolean equals(Object other);   &  ger true om objektet är lika med other \\
                  & int hashCode();                 &  ger objektets hashkod \\
                  & String toString();              &  ger en läsbar representation av objektet \secend
                  
Math              & \mc{Statiska konstanter Math.PI och Math.E. Metoderna är statiska (anropas med t~ex Math.round(x)):} \subsecend
                  & long round(double x);           &  avrundning, även float $\rightarrow$ int \\
                  & int abs(int x);                 &  $|x|$, även double, \ldots \\
                  & double hypot(double x, double y); &  $\sqrt{x^2+y^2}$ \\
                  & double sin(double x);           &  $\sin x$, liknande: cos, tan, asin, acos, atan \\
                  & double exp(double x);           &  $e^x$ \\
                  & double pow(double x, double y); &  $x^y$ \\
                  & double log(double x);           &  $\ln x$ \\
                  & double sqrt(double x);          &  $\sqrt{x}$ \\
                  & double toRadians(double deg);   &  $\mathit{deg} \cdot \pi / 180$ \secend

System            & void System.out.print(String s); &  skriv ut strängen s \\
                  & void System.out.println(String s); &  som print men avsluta med ny rad \\
                  & void System.exit(int status);   &  avsluta exekveringen, status != 0 om fel \\
                  & \mc{Parametern till print och println kan vara av godtycklig typ: int, double, \ldots} \secend
\end{etab}
\clearpage
\begin{etab}
Typklasser        & \mc{Till varje datatyp finns en typklass: char $\rightarrow$ Character, int $\rightarrow$ Integer, double $\rightarrow$ Double, \ldots\ Statiska konstanter MIN\_VALUE och MAX\_VALUE ger minsta respektive största värde. Exempel med klassen Integer:} \subsecend
                  & Integer(int value);             &  skapar ett objekt som innehåller value \\
                  & int intValue();                 &  tar reda på värdet \secend

String            & \mc{Teckensträngar där tecknen inte kan ändras. ''asdf'' är ett String-objekt. s1 + s2 för att konkatenera två strängar. StringIndexOutOfBoundsException om någon position är fel.} \subsecend
                  & int length();                   &  antalet tecken \\
                  & char charAt(int i);             &  tecknet på plats i, 0..length()$-1$ \\
                  & boolean equals(String s);       &  jämför innehållet (s1 == s2 fungerar inte) \\
                  & int compareTo(String s);        &  < 0 om mindre, = 0 om lika, > 0 om större \\
                  & int indexOf(char ch);           &  index för ch, $-1$ om inte finns \\
                  & int indexOf(char ch, int from); &  som indexOf men börjar leta på plats from \\
                  & String substring(int first, int last); &  kopia av tecknen first..last$-1$ \\
                  & String[\hspace{0.5mm}] split(String delim); &  ger vektor med ''ord'' (ord är följder av \\
                  &                                 &  tecken åtskilda med tecknen i delim) \secend

                  & \mc{Konvertering mellan standardtyp och String (exempel med int, liknande för andra typer):} \subsecend
                  & String.valueOf(int x);          &  x = 1234 $\rightarrow$ ''1234'' \\ 
                  & Integer.parseInt(String s);     &  s = ''1234'' $\rightarrow$ 1234, NumberFormat- \\
                  &                                 &  Exception om s innehåller felaktiga tecken \secend

StringBuilder     & \mc{Modifierbara teckensträngar. length och charAt som String, plus:} \subsecend
                  & StringBuilder(String s);        &  StringBuilder med samma innehåll som s \\
                  & void setCharAt(int i, char ch); &  ändrar tecknet på plats i till ch \\
                  & StringBuilder append(String s); &  lägger till s, även andra typer: int, char, \ldots \\
                  & StringBuilder insert(int i, String s); &  lägger in s med början på plats i \\
                  & StringBuilder deleteCharAt(int i); &  tar bort tecknet på plats i \\ 
                  & String toString();              &  skapar kopia som String-objekt
\end{etab}

\head{Standardklasser, import java.util.Classname}
\begin{etab}
List              & \mc{List<E> är ett gränssnitt som beskriver listor med objekt av parameterklassen E. Man kan lägga in värden av standardtyperna genom att kapsla in dem, till exempel int i Integer-objekt. Gränssnittet implementeras av klasserna ArrayList<E> och LinkedList<E>, som har samma operationer. Man ska inte använda operationerna som har en position som parameter på en LinkedList (i stället en iterator). IndexOutOfBoundsException om någon position är fel.} \subsecend
                  & \mc{För att operationerna contains, indexOf och remove(Object) ska fungera måste klassen E överskugga funktionen equals(Object). Integer och de andra typklasserna gör det.} \subsecend
ArrayList         & ArrayList<E>();                 &  skapar tom lista \\ 
LinkedList        & LinkedList<E>();                &  skapar tom lista \\ 
                  & int size();                     &  antalet element \\
                  & boolean isEmpty();              &  ger true om listan är tom \\
                  & E get(int i);                   &  tar reda på elementet på plats i \\
                  & int indexOf(Object obj);        &  index för obj, $-1$ om inte finns \\
                  & boolean contains(Object obj);   &  ger true om obj finns i listan \\

                  & void add(E obj);                &  lägger in obj sist, efter existerande element \\
                  & void add(int i, E obj);         &  lägger in obj på plats i (efterföljande \\
                  &                                 &  element flyttas) \\
                  & \ldots\ forts nästa sida        & 
\end{etab}
\secend
\begin{etab}
                  & E set(int i, E obj);            &  ersätter elementet på plats i med obj \\
                  & E remove(int i);                &  tar bort elementet på plats i (efter- \\
                  &                                 &  följande element flyttas) \\
                  & boolean remove(Object obj);     &  tar bort objektet obj, om det finns \\
                  & void clear();                   &  tar bort alla element i listan \secend

Random            & Random();                       &  skapar ''slumpmässig'' slumptalsgenerator \\
                  & Random(long seed);              &  -- med bestämt slumptalsfrö \\
                  & int nextInt(int n);             &  heltal i intervallet [0, n) \\
                  & double nextDouble();            &  double-tal i intervallet [0.0, 1.0) \secend

Scanner           & Scanner(File f);                &  läser från filen f, ofta System.in \\
                  & Scanner(String s);              &  läser från strängen s \\
                  & String next();                  &  läser nästa sträng fram till whitespace \\
                  & boolean hasNext();              &  ger true om det finns mer att läsa \\
                  & int nextInt();                  &  nästa heltal; också nextDouble(), \ldots \\
                  & boolean hasNextInt();           &  också hasNextDouble(), \ldots \\
                  & String nextLine();              &  läser resten av raden
\end{etab}



\head{Filer, import java.io.File/FileNotFoundException/PrintWriter}
\begin{etab}
Läsa från fil     & \mc{Skapa en Scanner med new Scanner(new File(filename)). Ger File\-NotFoundException om filen inte finns. Sedan läser man ''som vanligt'' från scannern (nextInt och liknande).} \subsecend
                  
Skriva till fil   & \mc{Skapa en PrintWriter med new PrintWriter(new File(filename)). Ger FileNotFoundException om filen inte kan skapas. Sedan skriver man ''som vanligt'' på PrintWriter-objektet (println och liknande).}\subsecend

Fånga undantag    & \mc{Så här gör man för att fånga FileNotFoundException:\\[1mm]
\ind Scanner scan = null;\\
\ind try $\{$\\
\ind \ind scan = new Scanner(new File("indata.txt"));\\
\ind $\}$ catch (FileNotFoundException e) $\{$\\
\ind \ind \ldots\ ta hand om felet\\
\ind $\}$}
\end{etab}


\head{Specialtecken}
\begin{etab}
                  & \mc{Några tecken måste skrivas på ett speciellt sätt när de används i teckenkonstanter:}\subsecend

& \textbackslash{}n & ny rad, radframmatningstecken\\
& \textbackslash{}t & ny kolumn, tabulatortecken (eng. tab)\\
& \textbackslash{}\textbackslash{} & bakåtsnedstreck: \textbackslash{} (eng. {\em backslash})\\
& \textbackslash{}'' & citationstecken: ''\\
& \textbackslash{}' & apostrof: '\\

\end{etab}

\head{Reserverade ord}\Newline

{\small Nedan 50 ord kan ej användas som identifierare i Java. Orden \jcode{goto} och \jcode{const} är reserverade men används ej.}
 
\begin{Code}[language=Java,morekeywords={assert, enum, strictfp}]
abstract assert boolean break byte case catch char class const 
continue default do double else enum extends final finally float for 
goto if implements import instanceof int interface long native new 
package private protected public return short static strictfp super 
switch synchronized this throw throws transient try void volatile while
\end{Code}

\end{document}