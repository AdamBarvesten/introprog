%!TEX encoding = UTF-8 Unicode
%!TEX root = ../lect-week07.tex

%%%


\begin{Slide}{TODO: Begrepp att förklara}
  Tänk igenom ordningen:
  \begin{itemize}
    \item OO, arv, supertyp, subtyp, bastyp, polymorfism, ... 
  \end{itemize}
\end{Slide}


\begin{Slide}{Medlemmar och arv}\footnotesize
\begin{multicols}{2}
Olika sorters medlemmar i \Emph{Scala}:
\begin{itemize}
\item \code{def}
\item \code{val}
\item \code{lazy val}
\item \code{var}
%\item \code{type}

\end{itemize}

\columnbreak

Olika sorters medlemmar i \Emph{Java}:
\begin{itemize}
\item variabel 
\item metod
\end{itemize}

\vspace{1em}

Variabler kan vara instansvariabler eller klassvariabler (nyckelord \jcode{static})

\end{multicols}

\pause
\begin{itemize}
\item Vid arv kan man överskugga \Eng{\code{override}} en medlem, så att medlemmen med samma namn i en subtyp får sin egen speciella skepnad.

\item När man konstruerar ett objektorienterat språk gäller det att man definierar sunda överskuggningsregler vid arv.
\end{itemize}
\end{Slide}


\begin{Slide}{Regler för \texttt{override} i Scala.} \fontsize{8}{11}\selectfont
\label{slideW07:overriderules}
En medlem M1 i en supertyp får ersättas av en medlem M2 i en subtyp, givet reglerna:
\begin{enumerate}
\item M1 och M2 ska ha samma namn och typerna ska matcha.
\item \code{def} får bytas ut mot: \code{def}, \code{val}, \code{var}, \code{lazy val}
\item \code{val} får bytas ut mot: \code{val}, och om M1 är abstrakt mot en \code{lazy val}.
\item \code{var} får bara bytas ut mot en \code{var}.
\item \code{lazy val} får bara bytas ut mot en \code{lazy val}.
\item Om en medlem i en supertyp är abstrakt \emph{behöver} man inte använda nyckelordet \code{override} i subtypen. (Men det är bra att göra det ändå så att kompilatorn hjälper dig att kolla att du verkligen byter ut något.) 
\item Om en medlem i en supertyp är konkret \emph{måste} man använda nyckelordet \code{override} i subtypen, annars ges kompileringsfel.
\item M1 får inte vara \code{final}.
\item M1 får inte vara \code{private} eller \code{private[this]}, men kan vara \code{private[X]} om M2 också är \code{private[X]}, eller \code{private[Y]} om X innehåller Y.   
\item Om M1 är \code{protected} måste även M2 vara det.

\end{enumerate}
\end{Slide}


\begin{Slide}{När använda en trait och när använda en klass som supertyp?} 
\fontsize{9}{11}\selectfont
\label{slideW07:traitorclass}
TODO
\begin{multicols}{2}
Använd en trait som supertyp om:
\begin{enumerate}
\item Du är osäker på vilket som är bäst. (Du kan alltid ändra till en klass senare.)
\item etc
\item etc
\end{enumerate}

\columnbreak

Använd en klass om:
\begin{enumerate}
\item Du vill ge supertypen en parameter vid konstruktion.
\item etc
\item etc
\end{enumerate}


\end{multicols}
\end{Slide}



\begin{Slide}{Designexempel: Klassen ???}\small
TODO:
  \begin{itemize} 
  \item 
  \end{itemize}
\end{Slide}










