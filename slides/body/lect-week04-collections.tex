%!TEX encoding = UTF-8 Unicode
%!TEX root = ../lect-week04.tex

\ifkompendium\else
\Subsection{Samlingar}

\begin{Slide}{Vad är en samling?}
En \Emph{samling} \Eng{collection} är en datastruktur som kan innehålla många element av \Alert{samma typ}.
\end{Slide}

\fi

\begin{Slide}{Hierarki av samlingar i scala.collection}
\includegraphics[width=1.0\textwidth]{../img/collection/collection-traits}
\end{Slide}

\noindent Läs mer om Scalas samlingar här: \\ 
\url{http://docs.scala-lang.org/overviews/collections/overview}

\ifkompendium\else

\begin{Slide}{scala.collection.immutable}
\includegraphics[width=0.82\textwidth]{../img/collection/collection-immutable}
\includegraphics[width=0.33\textwidth]{../img/collection/collection-legend}
\end{Slide}

\begin{Slide}{scala.collection.mutable}
\includegraphics[width=1.05\textwidth]{../img/collection/collection-mutable}
\end{Slide}


\begin{Slide}{Vector eller List???}\SlideFontTiny
\url{http://stackoverflow.com/questions/6928327/when-should-i-choose-vector-in-scala}

''
\begin{itemize}
\item We only need to transform sequences by operations like map, filter, fold etc: basically it does not matter, we should program our algorithm generically and might even benefit from accepting parallel sequences. For sequential operations List is probably a bit faster. But you should benchmark it if you have to optimize.

\item We need a lot of random access and different updates, so we should use vector, list will be prohibitively slow.

\item We operate on lists in a classical functional way, building them by prepending and iterating by recursive decomposition: use list, vector will be slower by a factor 10-100 or more.

\item We have an performance critical algorithm that is basically imperative and does a lot of random access on a list, something like in place quick-sort: use an imperative data structure, e.g. ArrayBuffer, locally and copy your data from and to it.


\end{itemize}
\end{Slide}

\fi





