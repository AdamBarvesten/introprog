%!TEX encoding = UTF-8 Unicode
%!TEX root = ../lect-week03.tex


\Subsection{Funktioner}



\begin{Slide}{Deklarera funktioner}
\begin{itemize}
\item En parameter, och sedan två parametrar:
\begin{REPL}
scala> :paste
  def öka(a: Int): Int = a + 1
  def öka(a: Int, b: Int) = a + b
  
scala> öka(1)
res0: Int = 2

scala> öka(1,1)
res1: Int = 2

\end{REPL}
\item Båda funktionerna ovan kan finnas samtidigt! Trots att de har samma namn är de \Alert{olika} funktioner; kompilatorn kan skilja dem åt med hjälp av de olika parameterlistorna.

\item Detta kallas \Emph{överlagring} \Eng{overloading} av funktioner.

\end{itemize}
\end{Slide} 


\begin{Slide}{Tom parameterlista och inga parametrar}\SlideFontSmall
\begin{itemize}
\item Om en funktion deklareras med tom parameterlista \code{()} kan den anropas på två sätt: med och utan tomma parenteser.
\begin{REPL}
scala> def tomParameterLista() = 42

scala> tomParameterLista()
res2: Int = 42

scala> tomParameterLista
res3: Int = 42
\end{REPL}

\item Men om parameterlista saknas får man \Alert{inte} använda \code{()} vid anrop:

\begin{REPL}

scala> def ingenParameterLista = 42

scala> ingenParameterLista
res4: Int = 42

scala> ingenParameterLista()
<console>:13: error: Int does not take parameters
       ingenParameterLista()
\end{REPL}

\end{itemize}
\end{Slide} 


\begin{Slide}{Funktioner med default-argument}\SlideFontSmall

\begin{itemize}
\item Vi kan ofta åstadkomma något som liknar överlagring, men med en enda funktion, om vi i stället använder \Emph{default-argument}:
\begin{REPLnonum}
scala> def inc(a: Int, b: Int = 1) = a + b
inc: (a: Int, b: Int)Int

scala> inc(42, 2)
res0: Int = 44

scala> inc(42, 1)
res1: Int = 43

scala> inc(42)
res2: Int = 43

\end{REPLnonum}
\item Om argumentet utelämnas och det finns ett default-argumentet, så är det default-argumentet som appliceras på parametern.
\end{itemize}
\end{Slide} 


\begin{Slide}{Stackminne och Heapminne}\SlideFontSmall
Minnet är uppdelat i två delar:
\begin{itemize}
\item \Emph{Stackminne}: På stacken läggs en \Emph{aktiveringspost} \Eng{stack frame\footnote{\href{https://en.wikipedia.org/wiki/Call_stack}{en.wikipedia.org/wiki/Call\_stack}}, activation record} för varje funktionsanrop med plats för parametrar och lokala variabler. Aktiveringsposten raderas när returvärdet har levererats. Stacken växer vid nästlade funktionsanrop, då en funktion i sin tur anropar en annan funktion. 

\item \Emph{Heapminne}: I heapminnet\footnote{\href{https://en.wikipedia.org/wiki/Memory_management}{en.wikipedia.org/wiki/Memory\_management}}$^{,}$\footnote{Ej att förväxlas med datastrukturen heap  \href{https://sv.wikipedia.org/wiki/Heap}{sv.wikipedia.org/wiki/Heap}} sparas alla objekt (data) som allokeras under körning. Heapminnet städas vid tillfälle av skräpsamlaren \Eng{garbage collector}, och minne som inte används längre frigörs. \\\vspace{0.5em}
\href{http://stackoverflow.com/questions/1565388/increase-heap-size-in-java}{stackoverflow.com/questions/1565388/increase-heap-size-in-java}
\end{itemize}
\end{Slide} 


\begin{Slide}{Aktiveringspost}\SlideFontSmall
Nästlade anrop ger växande stackminne.
\begin{REPL}
scala> :paste
def f(): Unit = { val n = 5; g(n, 2 * n) }
def g(a: Int, b: Int): Unit = { val x = 1; h(x + 1, a + b) }
def h(x: Int, y: Int): Unit = { val z = x + y; println(z) }

scala> f()

\end{REPL}

\Alert{Stacken}

\begin{tabular}{|r | l | l |} \hline

variabel & värde & Vilken aktiveringspost? \\ \hline \hline
\pause
 n & 5 & f \\ \hline
 \pause 
 a & 5 & g \\
 b & 10 &  \\
 x & 1  &  \\  \hline
 \pause 
 x & 2  & h \\
 y & 15 &  \\
 z & 17 & \\ 
\end{tabular}
\end{Slide} 


\begin{Slide}{Lokala funktioner}
\end{Slide} 



\begin{Slide}{Värdeanrop och namnanrop}
\begin{itemize}
\item 
\end{itemize}
\end{Slide} 



\begin{Slide}{Uppdelad parameterlista}
\begin{itemize}
\item 
\end{itemize}
\end{Slide} 


\begin{Slide}{Skapa din egen kontrollstruktur}
\begin{itemize}
\item 
\end{itemize}
\end{Slide} 


\begin{Slide}{Funktioner med namngivna argument}
\begin{itemize}
\item 
\end{itemize}
\end{Slide} 



\begin{Slide}{Funktioner är äkta värden i Scala}
\begin{itemize}
\item En funktioner är ett äkta värde; vi kan till exempel tilldela en variabel ett funktionsvärde:
\item Funktioner har en typ precis som alla värden:
\end{itemize}
\end{Slide} 



\begin{Slide}{Anonyma funktioner}
\begin{itemize}
\item 
\end{itemize}
\end{Slide}




\begin{Slide}{Applicera funktioner på element i samlingar}
\begin{itemize}
\item 
\end{itemize}
\end{Slide} 




\begin{Slide}{Stegade funktioner, ''Curry-funktioner''}
\begin{itemize}
\item 
\end{itemize}
\end{Slide} 





\Subsection{Objekt}

\begin{Slide}{Objekt som modul}
\begin{itemize}
\item Ett \code{object} användas ofta för att samla \Emph{medlemmar} som hör ihop och ge dem en egen \Emph{namnrymd}. 
\item Medlemmarna kan vara t.ex.: 
\begin{itemize}
\item  \code{val} \item \code{var} \item \code{def} 
\end{itemize}
\item Ett sådant objekt kallas även för \Emph{modul}.\footnote{
Även paket som skapas med \code{package} har en egen namnrymd och är därmed också en slags modul. Objekt kan alltså i Scala användas som ett alternativ till paket; en skillnad är att objekt kan ha tillstånd och att objekt inte skapar underkataloger vid kompilering.  \href{https://en.wikipedia.org/wiki/Modular_programming}{en.wikipedia.org/wiki/Modular\_programming}}

\end{itemize}

\end{Slide}


\begin{Slide}{Vad är ett tillstånd?} 
\end{Slide} 

\begin{Slide}{Lata variabler och fördröjd evaluering} 
\end{Slide} 

\begin{Slide}{Vad är egentligen skillnaden mellan \texttt{val}, \texttt{lazy val}, \texttt{var}, \texttt{def}?} 

En funktion som finns inuti ett objekt är en \Emph{metod}.
\end{Slide} 


\Subsection{Funktioner är objekt}

\begin{Slide}{Programmeringsparadigm}
\end{Slide} 


\begin{Slide}{Funktioner är äkta objekt i Scala}
Scala visar hur man kan \Alert{förena} \Eng{unify} objekt-orientering och funktionsprogrammering på ett elegant \& pragmatiskt sätt: \\\vspace{2em}

\Emph{\Large En funktion är ett objekt \\ som har en \code{apply}-metod.}

\end{Slide} 



\Subsection{Rekursion}
\begin{Slide}{Rekursiva funktioner}
\end{Slide} 

\begin{Slide}{Rekursiva datastrukturer}
\end{Slide} 

