%!TEX encoding = UTF-8 Unicode
%!TEX root = ../lect-week03.tex


\Subsection{Funktioner}



\begin{Slide}{Deklarera funktioner}
Exempel på deklaration av två olika funktioner:
\begin{itemize}
\item En parameter, och sedan två parametrar:
\begin{REPLnonum}
scala> def öka(a: Int): Int = a + 1
scala> def öka(a: Int, b: Int) = a + b
\end{REPLnonum}
\item Båda ovan funktioner kan finnas samtidigt: De är \Alert{olika} funktioner, om det finns en skillnad i paramterlistan. Trots att de har samma namn är det två olika funktioner, och kompilatorn kan skilja dem åt med hjälp av parameterlistorna.

\item Detta kallas \Emph{överlagring} \Eng{overloading} av funktioner.
\end{itemize}
\end{Slide} 


\begin{Slide}{Funktioner med default-argument}\SlideFontSmall

\begin{itemize}
\item Vi kan ofta åstadkomma något som liknar överlagring, men med en enda funktion, om vi i stället använder \Emph{default-argument}:
\begin{REPLnonum}
scala> def inc(a: Int, b: Int = 1) = a + b
inc: (a: Int, b: Int)Int

scala> inc(42, 2)
res0: Int = 44

scala> inc(42, 1)
res1: Int = 43

scala> inc(42)
res2: Int = 43

\end{REPLnonum}
\item Om argumentet utelämnas och det finns ett default-argumentet, så är det default-argumentet som appliceras på parametern.
\end{itemize}
\end{Slide} 


\begin{Slide}{Aktiveringspost}
\end{Slide} 


\begin{Slide}{Lokala funktioner}
\end{Slide} 



\begin{Slide}{Värdeanrop och namnanrop}
\begin{itemize}
\item 
\end{itemize}
\end{Slide} 



\begin{Slide}{Uppdelad parameterlista}
\begin{itemize}
\item 
\end{itemize}
\end{Slide} 


\begin{Slide}{Skapa din egen kontrollstruktur}
\begin{itemize}
\item 
\end{itemize}
\end{Slide} 


\begin{Slide}{Funktioner med namngivna argument}
\begin{itemize}
\item 
\end{itemize}
\end{Slide} 



\begin{Slide}{Funktioner är äkta värden i Scala}
\begin{itemize}
\item En funktioner är ett äkta värde; vi kan till exempel tilldela en variabel ett funktionsvärde:
\item Funktioner har en typ precis som alla värden:
\end{itemize}
\end{Slide} 



\begin{Slide}{Anonyma funktioner}
\begin{itemize}
\item 
\end{itemize}
\end{Slide}




\begin{Slide}{Applicera funktioner på element i samlingar}
\begin{itemize}
\item 
\end{itemize}
\end{Slide} 




\begin{Slide}{Stegade funktioner, ''Curry-funktioner''}
\begin{itemize}
\item 
\end{itemize}
\end{Slide} 





\Subsection{Objekt}

\begin{Slide}{Objekt som modul}
\begin{itemize}
\item Ett \code{object} användas ofta för att samla \Emph{medlemmar} som hör ihop och ge dem en egen \Emph{namnrymd}. 
\item Medlemmarna kan vara t.ex.: 
\begin{itemize}
\item  \code{val} \item \code{var} \item \code{def} 
\end{itemize}
\item Ett sådant objekt kallas även för \Emph{modul}.\footnote{
Även paket som skapas med \code{package} har en egen namnrymd och är därmed också en slags modul. Objekt kan alltså i Scala användas som ett alternativ till paket; en skillnad är att objekt kan ha tillstånd och att objekt inte skapar underkataloger vid kompilering.  \href{https://en.wikipedia.org/wiki/Modular_programming}{en.wikipedia.org/wiki/Modular\_programming}}

\end{itemize}

\end{Slide}


\begin{Slide}{Vad är ett tillstånd?} 
\end{Slide} 

\begin{Slide}{Lata variabler och fördröjd evaluering} 
\end{Slide} 

\begin{Slide}{Vad är egentligen skillnaden mellan \texttt{val}, \texttt{lazy val}, \texttt{var}, \texttt{def}?} 

En funktion som finns inuti ett objekt är en \Emph{metod}.
\end{Slide} 


\Subsection{Funktioner är objekt}

\begin{Slide}{Programmeringsparadigm}
\end{Slide} 


\begin{Slide}{Funktioner är äkta objekt i Scala}
Scala visar hur man kan \Alert{förena} \Eng{unify} objekt-orientering och funktionsprogrammering på ett elegant \& pragmatiskt sätt: \\\vspace{2em}

\Emph{\Large En funktion är ett objekt \\ som har en \code{apply}-metod.}

\end{Slide} 



\Subsection{Rekursion}
\begin{Slide}{Rekursiva funktioner}
\end{Slide} 

\begin{Slide}{Rekursiva datastrukturer}
\end{Slide} 

