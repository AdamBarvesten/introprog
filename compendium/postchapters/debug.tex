%!TEX encoding = UTF-8 Unicode
%!TEX root = ../compendium.tex

\chapter{Fixa fel}\label{appendix:debug}



\section{Vad är en bugg?}

En bugg är en oönskad egenskap hos ett program. 

\textbf{Varför heter det bugg?}


\textbf{Olika sorters fel?}

Kompileringsfel och exekveringsfel. 

Oändliga loopar eller bara långsamt... 

Det är viktigt att skilja på felorsak och felyttring.

\textbf{Bugg eller feature?} Är det verkligen ett fel eller är det egentligen ett avsett beteende?

\textbf{Felhanteringsverktyg} exempel Jira.
s
\section{Förebygga fel}

\begin{itemize}
\item \textbf{Begriplig kod}.
\item \textbf{Bra namn}.
\item \textbf{Typannoteringar}.
\item \textbf{Kontrollera villkor}.
\item \textbf{Hantera saknade värden}.
\item \textbf{Slänga undantag}.
\item \textbf{Granska kod}.
\item \textbf{Testa kod}.
\end{itemize}


\section{Vad är debugging?}

När fel identifierats, vid testning eller under användning av slutanvändare ''i produktion'' ska felorsaken hittas och felet åtgärdas. Detta kallas avlusning \Eng{debugging}.

Identifiering går vi inte vidare in på här. Testning är ett stort område....



\section{Hitta felorsaken}

När det blir fel som är svåra att hitta beror det ofta på att man har en felaktig hypotes om vad koden egentligen gör. Du stirrar dig blind på ett kodstycke och är övertygad om att en viss sak händer, men \emph{egentligen} är det \emph{inte} det du \emph{tror} händer som \emph{verkligen} händer. Exempelvis kanske du antar att en räknare räknas upp i en loop, men i själva verket saknas uppräkningen. 

En grundläggande princip i felsökning är att explicit formulera dina hypoteser och seda verifiera att de verkligen stämmer. Du ska alltså tydligt beskriva hur du tror att koden fungerar och sedan med olika former av instrumentering, t.ex. genom utskrifter i terminalen av variablers värden, kontrollera att så verkligen är fallet.

\subsection{Återskapa buggen med ett minimalt testfall}

\subsection{Instrumentering med utskrifter, ''print-debugging''}

\section{Använda en debugger}

\begin{itemize}
\item \textbf{Sätta brytpunkter}.
\item \textbf{Stegad exekvering}.
\item \textbf{Inspektera variabler}.
\end{itemize}

\subsection{Debuggern i Eclipse med ScalaIDE}
\subsubsection{Sätta brytpunkter i Eclipse}
\subsubsection{Stegad exekvering i Eclipse}
\subsubsection{Inspektera variabler i Eclipse}

\subsection{Debuggern i IntelliJ IDEA med Scala-plugin}
\subsubsection{Sätta brytpunkter i IntelliJ}
\subsubsection{Stegad exekvering i IntelliJ}
\subsubsection{Inspektera variabler i IntelliJ}



\section{Åtgärda fel}

Ibland är det det svåraste att \emph{hitta} buggen medan själva buggrättningen visar sig trivial. Har du, till exemple, väl hittat den saknade uppräkningen av din loop-variabel är det uppenbart vad du ska göra.

Men ibland är det riktigt knepigt att åtgärda felet. Nedan sammanfattas några av de situationer som kan uppkomma, som gör att felrättningen blir långt ifrån trivial. 

\begin{itemize}
\item Kanske är själva algoritmen i grunden feltänkt och en helt ny algoritm behöver konstrueras. Att skapa nya algoritmer från grunden kan visa sig mycket svårt i en del fall. I fortsättningskurser får du lära dig mer om algoritmkonstruktionens svåra konst.

\item Kanske algoritmen fungerar för olika normalfall, medan undantagsfallen inte hanteras korrekt. Att på ett bra sätt hantera alla upptänkliga fall kan visa sig väldigt knepigt. Tyvärr är det ofta undantagsfallen som öppnar för säkerhetsluckor som elaka hackare kan utnyttja för att få systemet att krascha eller smittas av virus.

\item Kanske är problemet i sig väldigt svårt att lösa på ett korrekt sätt. Algoritmen kan vara riktigt knepig med många villkor, loopar och nästlade datastrukturer. Blir det fel i en sådan algoritm kan det ta lång tid att få ändringar att fungera och alla villkor, loopar och nästlade datastrukter att passa ihop. 

\item Medan man rättar en bug kan man råka att, av misstag, skapa nya buggar. Risken för detta är speciellt stor om koden är komplex. Ibland låter man till och med bli att åtgärda ett fel om systemet ändå fungerar hjälpligt i andra avseenden och risken är för stor att ändra innan systemet strukturerats om så att det blir lättare att ändra i.

\item Kanske växer exekveringstiden exponetiellt med datamängden och det kan vara i praktiken omöjligt att skriva ett program som i alla lägen blir färdigt inom rimlig tid för tillräckigt stora datamängder. Då får man försöka tänka ut kluriga genvägar och det kan vara riktigt svårt och ibland kräva mycket avancerad programmeringsteknik.
 
\end{itemize}