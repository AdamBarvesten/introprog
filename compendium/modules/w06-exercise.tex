%!TEX encoding = UTF-8 Unicode

%!TEX root = ../compendium.tex

\Exercise{\ExeWeekSIX}

\begin{Goals}
\item Kunna deklarera klasser med klassparametrar.
\item Kunna skapa objekt med \code{new} och konstruktorargument.
\item Förstå innebörden av referensvariabler och värdet \code{null}.
\item Förstå innebörden av begreppen instans och referenslikhet.
\item Kunna använda nyckelordet \code{private} för att styra synlighet i primärkonstruktor.
\item Förstå i vilka sammanhang man kan ha nytta av en privat konstruktor.
\item Kunna implementera en klass utifrån en specikation.
\item Förstå skillnaden mellan referenslikhet och strukturlikhet.
\item Känna till hur case-klasser hanterar likhet.
\item Förstå nyttan med att möjliggöra framtida förändring av attributrepresentation.
\item Känna till begreppen getters och setters. 
\item Känna till accessregler för kompanjonsobjekt.
\item Känna till skillnaden mellan \code{==} och \code{eq}, samt \code{!=} versus \code{ne}.
\end{Goals}

\begin{Preparations}
\item Studera teorin i kapitel \ref{chapter:W06}.
\end{Preparations}

\BasicTasks %%%%%%%%%%%%%%%%

\Task \emph{Instansiering med \code{new} och värdet \code{null}.} Man skapar instanser av klasser med \code{new}. Då anropas konstruktorn och plats reserveras i datorns minne för objektet. Variabler av referenstyp som inte refererar till något objekt har värdet \code{null}. 

\Subtask Vad händer nedan? Vilka rader ger felmeddelande och i så fall hur lyder felmeddelandet?

\begin{REPL}
scala> class Gurka(val vikt: Int)
scala> var g: Gurka = null
scala> g.vikt
scala> g = new Gurka(42)
scala> g.vikt
scala> g = null
scala> g.vikt
\end{REPL}

\Subtask\Pen Rita minnessituationen efter raderna 2, 4, 6.

\Task \emph{Klasser och instanser.} 

\Subtask Vad händer nedan?
\begin{REPL}
scala> :pa
class Arm(val ärTillVänster: Boolean)  
class Ben(val ärTillVänster: Boolean)
class Huvud(val harHår: Boolean)
class RymdVarelse {
  var arm1 = new Arm(true)
  var arm2 = new Arm(false)
  var ben1 = new Ben(true)
  var ben2 = new Ben(false)
  var huvud1 = new Huvud(false)
  var huvud2 = new Huvud(true)
  def ärSkallig = !huvud1.harHår && !huvud2.harHår
}
scala> val alien = new RymdVarelse
scala> alien.ärSkallig
scala> val predator = new RymdVarelse
scala> predator.ärSkallig
scala> predator.huvud2 = alien.huvud1
scala> predator.ärSkallig
\end{REPL}

\Subtask\Pen Rita minnessituationen efter rad 18.

\Subtask\Pen Vad händer så småningom med det ursprungliga huvud2-objektet i predator efter tilldelningen på rad 18? Går det att referera till detta objekt på något sätt?


\Task \emph{Synlighet i primärkonstruktorer.} Undersök nedan vad nyckelorden \code{val} och \code{private} får för konsekvenser. Förklara vad som händer. Vilka rader ger vilka felmeddelanden?

\begin{REPL}
scala> class Gurka1(vikt: Int)
scala> new Gurka1(42).vikt
scala> class Gurka2(val vikt: Int)
scala> new Gurka2(42).vikt
scala> class Gurka3(private val vikt: Int)
scala> new Gurka3(42).vikt
scala> class Gurka4(private val vikt: Int, kompis: Gurka4){
         def kompisVikt = kompis.vikt
       }
scala> val ingenGurka: Gurka4 = null
scala> new Gurka4(42, ingenGurka).kompisVikt
scala> new Gurka4(42, new Gurka4(84, null)).kompisVikt
scala> class Gurka5(private[this] val vikt: Int, kompis: Gurka5){
         def kompisVikt = kompis.vikt
       }
scala> class Gurka6 private (vikt: Int)
scala> new Gurka6(42)
scala> :pa
class Gurka7 private (var vikt: Int)
object Gurka7 { 
  def apply(vikt: Int) = {
    require(vikt >= 0, s"negativ vikt: $vikt")
    new Gurka7(vikt)
  }
}
scala> new Gurka7(-42)
scala> Gurka7(-42)
scala> val g = Gurka7(42)
scala> g.vikt
scala> g.vikt = -1
scala> g.vikt 
\end{REPL}


\Task \emph{Egendefinierad setter kombinerat med privat konstruktor.} 

\Subtask Förklara vad som händer nedan. Vilka rader ger vilka felmeddelanden?
\begin{REPL}
scala> :pa
class Gurka8 private (private var _vikt: Int) {
  def vikt = _vikt
  def vikt_=(v: Int): Unit = {
    require(v >= 0, s"negativ vikt: $v")
    _vikt = v
  }
}

object Gurka8 { 
  def apply(vikt: Int) = {
    require(vikt >= 0, s"negativ vikt: $vikt")
    new Gurka8(vikt)
  }
}
scala> val g = Gurka8(-42)
scala> val g = Gurka8(42)
scala> g.vikt
scala> g.vikt = 0
scala> g.vikt = -1
scala> g.vikt += 42
scala> g.vikt -= 1000
\end{REPL}

\Subtask\Pen Vad är fördelen med möjligheten att skapa egendefienerade setters?

\Task \label{task:Square} \emph{Klassen \code{Square}.} 

\Subtask Implementera \code{Square} enligt nedan specifikation. Gör  implementationen i en kodeditor, så som \code{gedit}, och klistra in klassen i Scala REPL efter kommandot \code{:pa} (förkortning av \code{:paste}). På så sätt blir \code{object Square} ett kompanjonsobjekt till \code{class Square}.

\begin{ScalaSpec}{Square}
/** A class representing a square object with position and side. */
class Square(val x: Int, val y: Int, val side: Int) {
  /** The area of this Square */
  val area: Int = ???
  
  /** Creates a new Square moved to position (x + dx, y + dy) */
  def move(dx: Int, dy: Int): Square = ???
  
  /** Tests if this Square has equal size as that Square */
  def isEqualSizeAs(that: Square): Boolean = ???
  
  /** Multiplies the side with factor and rounded to nearest integer */
  def scale(factor: Double): Square = ???
  
  /** A string representation of this Square */
  override def toString: String = ???
}

object Square {
  /** A square placed in origin with size 1 */
  val unit: Square = ??? 
  
  /** Constructs a new Square object at (x, y) with size side */
  def apply(x: Int, y: Int, side: Int): Square = ???

  /** Constructs a new Square object at (0, 0) with side 1 */
  def apply(): Square = ???
}
\end{ScalaSpec}

\Subtask Testa din kvadrat enligt nedan. Förklara vad som händer.

\begin{REPL}
scala> val (s1, s2) = (Square(0,0,2), Square(1, 10, 2))
scala> val s3 = s1.move(1,-5)
scala> s1 isEqualSizeAs s3
scala> s2 isEqualSizeAs s1
scala> s2.scale(math.Pi) isEqualSizeAs s2
scala> s2.scale(math.Pi) isEqualSizeAs s2.scale(math.Pi)
\end{REPL}





\Task \emph{Referenslikhet versus strukturlikhet.} Metoden \code{==} på case-klasser ger \textbf{strukturlikhet} (även kallad innehållslikhet) så att \emph{innehållet} i klassens klassparametrar jämförs om de har lika värde, medan för vanliga klasser ger metoden \code{==} \textbf{referenslikhet} där olika objekt är olika även om de har samma innehåll (om man inte byter ut metoden \code{equals} som anropas av \code{==} -- detta ska vi titta närmare på i kapitel \ref{chapter:W08}).

\begin{REPL}
scala> class GurkaRef(val vikt: Int)
scala> case class GurkaStrukt(val vikt: Int)
scala> val a = new GurkaRef(42)
scala> val b = new GurkaRef(42)
scala> val c = new GurkaStrukt(42)
scala> val d = new GurkaStrukt(42)
scala> a == b
scala> c == d 
\end{REPL}

\Subtask Förklara vad som händer ovan.

\Subtask Istället för \code{==}, prova metoden \code{eq} på objekten ovan. Metoden \code{eq} ger alltid referenslikhet (även om byter ut metoden \code{equals}).



\Task \label{task:Point} \emph{Klassen \code{Point} med case-klass.} 

\Subtask Implementera klassen \code{Point} som en oföränderlig case-klass med heltalsattributen \code{x} och \code{y}. 

\Subtask Lägg till metoden \code{distanceTo(that: Point): Double} som räknar ut avståndet till en annan punkt med hjälp av \code{math.hypot}.

\Subtask Lägg till metoden \code{distanceTo(x: Int, y: Int): Double} som räknar ut avståndet till koordinaterna x och y med hjälpa av metoden i föregående deluppgift.

\Subtask Lägg till metoden \code{move(dx: Int, dy: Int): Point} som skapar en ny punkt på translaterad position enligt delta-koordinaterna \code{dx} och {dy}.

\Subtask Lägg till ett kompanjonsobjekt med medlemmen \code{val origin} som ger en punkt i origo.

\Subtask Undersök metoderna \code{==}, \code{!=}, \code{eq} och \code{ne} och förklara vad som händer nedan:
\begin{REPL}
scala> Point(1, 2) == Point(1, 3)
scala> Point(1, 2) != Point(1, 3)
scala> Point(1, 2) == Point(1, 2)
scala> Point(1, 2) != Point(1, 2)
scala> Point.origin.move(1, 1) == Point.origin.move(1, 1)
scala> Point.origin.move(1, 1).move(1, 1) != Point(2, 2)
scala> Point(0, 0) eq Point(0, 0)
scala> Point(0, 0) ne Point(0, 0)
scala> Point.origin eq Point.origin
scala> Point.origin ne Point.origin
scala> val p1 = Point(0, 0)
scala> val p2 = p1
scala> p1 eq p2
\end{REPL}

\Subtask Vad ger \code{Point.origin eq Point.origin} för resultat om \code{origin} istället  implementeras som \code{def origin: Point = Point(0, 0)}

\Subtask\Pen Vad är det för skillnad på strukturlikhet och referenslikhet?

\begin{CodeSmall}
// kod till facit
case class Point(x: Int, y: Int) {
  def distanceTo(that: Point): Double = math.hypot(that.x - x, that.y -y)
  
  def distanceTo(x: Int, y: Int): Double = distanceTo(Point(x, y)) 
  
  def move(dx: Int, dy: Int): Point = Point(x + dx, y + dy)
}

object Point {
  val origin: Point = new Point(0, 0)
}
\end{CodeSmall}


\Task Ändra representationen av positionen i klassen \code{Square} från deluppgift \ref{task:Square} till att vara en \code{Point} från deluppgift \ref{task:Point}.


\Task \label{task:PointTuple} \emph{Case-klassen \code{Point} med 2-tupel.} I ett utvecklingsprojekt vill man ändra representationen av positionen i den gamla klassen  \\ \code{case class Point(x: Int, y: Int)} så att positionen istället i den uppdaterade klassen representeras av en 2-tupel. Man kan då vid konstruktion utnyttja att n-tupler som parameter även kan skrivas som en parameterlista med n argument, varför både \code{Point(1,2)} och \code{Point((1,2))} fungerar fint. Samtidigt vill man att befintlig kod som fortfarande använder \code{x} och \code{y} ska fungera utan ändringar.  Implementera den nya \code{Point} enligt specifikationen nedan. 
\begin{ScalaSpec}{Point}
/** A 2-dimensional immutable position p in an integer coordinate system */ 
case class Point(p:(Int, Int)) {
  /** The x-axis position of this Point */
  val x: Int = ???

  /** The y-axis position of this Point */
  val y: Int = ???

  /** The distance to another Point that */
  def distanceTo(that: Point): Double = ???

  /** The distance to another 2-tuple that representing (x, y). */
  def distanceTo(that: (Int, Int)): Double = ???

  /** A new Point that is moved (dx, dy) */
  def move(dxdy: (Int, Int)): Point = ???
}

object Point {
  /** A Point object at position (0, 0) */ 
  val origin: Point = ???
}
\end{ScalaSpec}

\begin{CodeSmall}
// kod till facit
case class Point(p:(Int,Int)) {
  val x: Int = p._1
  
  val y: Int = p._2
  
  def distanceTo(that: Point): Double = 
    math.hypot(that.x - x, that.y -y)
  
  def distanceTo(that: (Int, Int)): Double = 
    distanceTo(Point(that)) 
  
  def move(dx: Int, dy: Int): Point = Point(x + dx, y + dy)
}

object Point {
  val origin: Point = new Point(0, 0)
}
\end{CodeSmall}



\Task\Pen Vad behöver du ändra i klassen \code{Square} från uppgift \ref{task:Square} för att den ska fungera med en \code{Point} med 2-tupel från uppgift \ref{task:PointTuple}?





\ExtraTasks %%%%%%%%%%%%%%%%%%%

\Task \code{class Frac private (numerator: BigInt, denominator: BigInt)}  TODO: Ungefär som Rational i pins1ed med GCD



\Task \emph{Klassen \code{Frog}} 

\Subtask 

\begin{ScalaSpec}{Frog}
class Frog(startX: Int, startY: Int) {

  def jump(dx: Int, dy: Int): Unit = ???

  def x: Int = ??? 
  
  def y: Int = ???
 
  def randomJump: Unit = ???
  
  def distanceToStart: Double = ???
  
  def distanceJumped: Double = ???
}

\end{ScalaSpec}

\Task \emph{En föränderlig kvadrat.} 

\begin{CodeSmall}
/** A class representing a square objects with position and side. */
class Square private (val initX: Int, val initY: Int, val initSide: Int) {
  
  private var numberOfMoves = 0;
  private var _x = initX;
  private var _y = initY;
  private var _side = initSide;
  
  def x: Int = _x
  def y: Int = _y
  def pos: (Int, Int) = ???
  def side = _side

  /** The area of this Square */
  def area: Int = ???

  /** Moves this square to position (x + xd, y + dy) */
  def move(dx: Int, dy: Int): Unit = ???

  /** Moves this square to position (x, y) */
  def moveTo(x: Int, y: Int): Unit = ???

  /** A string representation of this Square */
  override def toString: String = 
    s"Square[x: $x, y: $y, side: $side, #moved: $numberOfMoves]"
}

object Square {
  private var created = Vector[Square]()
 
  /** Creates a Square, saves a ref in created and returns the newly created Square */  
  private def create(x: Int, y: Int, side: Int, nMoves: Int): Square = ???
 
  /** A square placed in origin with size 1 */
  val unit: Square =  create(0, 0, 1, 0)

  /** Constructs a new Square object at (x, y) with size side */
  def apply(x: Int, y: Int, side: Int): Square = {
    require(side >= 0, s"side must be positive: $side")
    create(x, y, side, 0)
  }

  /** Constructs a new Square object at (0, 0) with side 1 */
  def apply(): Square = create(0, 0, 1, 0)

  /** Returns the total number of moves that have been made */
  def totalNumberOfMoves: Int = ???
} 
\end{CodeSmall}

\Subtask\Pen Varför är det avgörande för korrektheten av beräkningen av totala antalet förflyttningar i föregående uppgift att konstruktorn i klassen \code{Square} är privat? 

\Subtask\Pen Vad kallas en metod som gör \code{new} och returnerar referensen till det nyskapade objektet?


\begin{CodeSmall}
// Kod till facit
class Square private (val x: Int, val y: Int, val side: Int) {

  private var numberOfMoves = 0
  
  val area: Int = side*side

  def move(dx: Int, dy: Int): Square =
    Square.create(x + dx, y + dy, side, numberOfMoves + 1)

  def isEqualSizeAs(that: Square): Boolean = side == that.side

  def scale(factor: Double): Unit =
    Square.create(x, y, math.rint(side*factor).toInt, numberOfMoves)
   
  override def toString: String = s"x: $x, y: $y, side: $side, #moved: $numberOfMoves"
}

object Square {
  private var created = Vector[Square]()
 
  private def create(x: Int, y: Int, side: Int, nMoves: Int): Square = {
    created :+= new Square(x, y, side, nMoves)    
    created.last    
  }
 
  val unit: Square =  create(0, 0, 1, 0)

  def apply(x: Int, y: Int, side: Int): Square = {
    require(side >= 0, s"side must be positive: $side")
    create(x, y, side, 0)
  }

  def apply(): Square = create(0, 0, 1, 0)

  def totalNumberOfMoves: Int = created.map(_.numberOfMoves).sum
} 
\end{CodeSmall}

\AdvancedTasks %%%%%%%%%%%%%%%%%

\Task     
    