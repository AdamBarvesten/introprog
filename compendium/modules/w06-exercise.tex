%!TEX encoding = UTF-8 Unicode

%!TEX root = ../compendium.tex

\Exercise{\ExeWeekSIX}

\begin{Goals}
\item 
\end{Goals}

\begin{Preparations}
\item 
\end{Preparations}

\BasicTasks %%%%%%%%%%%%%%%%


\Task \emph{\code{private}.} Undersök nedan vad nyckelorder \code{private} får för konsekvenser. Förklara vad som händer. Vilka rader ger vilka felmeddelanden?

\begin{REPL}
scala> class Gurka1(vikt: Int)
scala> new Gurka1(42).vikt
scala> class Gurka2(val vikt: Int)
scala> new Gurka2(42).vikt
scala> class Gurka3(private val vikt: Int)
scala> new Gurka3(42).vikt
scala> class Gurka4(private val vikt: Int, kompis: Gurka4){
         def kompisVikt = kompis.vikt
       }
scala> new Gurka4(42, null).kompisVikt
scala> new Gurka4(42, new Gurka4(84, null)).kompisVikt
scala> class Gurka5(private[this] val vikt: Int, kompis: Gurka5){
         def kompisVikt = kompis.vikt
       }
\end{REPL}


\Task \label{task:Square} \emph{Klassen \code{Square}.} 

\Subtask Implementera \code{Square} enligt nedan specifikation. Gör  implementationen i en kodeditor, så som \code{gedit}, och klistra in klassen i Scala REPL efter kommandot \code{:pa} (förkortning av \code{:paste}). På så sätt blir \code{object Square} ett kompanjonsobjekt till \code{class Square}.

\begin{ScalaSpec}{Square}
/** A class representing a square objects with position and side. */
class Square(val x: Int, val y: Int, val side: Int) {
  /** The area of this Square */
  val area: Int = ???
  
  /** Moves this square to position (x + xd, y + dy) */
  def move(dx: Int, dy: Int): Square = ???
  
  /** Tests if this Square has equal size as that Square */
  def isEqualSizeAs(that: Square): Boolean = ???
  
  /** Multiplies the side with factor and rounded to nearest integer */
  def scale(factor: Double): Square = ???
  
  /** A string representation of this Square */
  override def toString: String = ???
}

object Square {
  /** A square placed in origin with size 1 */
  val unit: Square = ??? 
  
  /** Constructs a new Square object at (x, y) with size side */
  def apply(x: Int, y: Int, side: Int): Square = ???

  /** Constructs a new Square object at (0, 0) with side 1 */
  def apply(): Square = ???
}
\end{ScalaSpec}

\Subtask Testa din kvadrat enligt nedan. Förklara vad som händer.

\begin{REPL}
scala> val (s1, s2) = (Square(0,0,2), Square(1, 10, 2))
scala> val s3 = s1.move(1,-5)
scala> s1 isEqualSize s3
scala> s2 isEqualSize s1
scala> s2.scale(math.Pi) isEqualSize s2
scala> s2.scale(math.Pi) isEqualSize s2.scale(math.Pi)
\end{REPL}

\Subtask Gör primärkonstruktorn i klassen \code{Square} privat och säkerställ i fabriksobjektet att det inte går att skapa kvadrater med negativ sida. Använd \code{assert}.  

\Subtask Lägg till ett privat attribut \code{var moved: Int} i klassen Square som räknar hur många gånger en instans har flyttats. 

\Subtask Lägg till en privat variabel \code{var created: Vector[Square]} i kompanjonsobjektet som sparar alla kvadratobjekt som skapats.

\Subtask Lägg till en metod \code{def totalMoved: Int} i kompanjonsobjektet som räknar ut det totala antalet förflyttningar som skett.

\Subtask\Pen Varför är det avgörande för korrektheten av beräkningen av totala antalet förflyttningar i föregående uppgift att konstruktorn i klassen \code{Square} är privat? 



\Task \label{task:Point} \emph{Klassen \code{Point} med case-klass.} 

\Subtask Implementera klassen \code{Point} som en oföränderlig case-klass med heltalsattributen \code{x} och \code{y}. 

\Subtask Lägg till metoden \code{distanceTo(that: Point): Double} som räknar ut avståndet till en annan punkt med hjälp av \code{math.hypot}.

\Subtask Lägg till metoden \code{distanceTo(x: Int, y: Int): Double} som räknar ut avståndet till koordinaterna x och y med hjälpa av metoden i föregående deluppgift.

\Subtask Lägg till metoden \code{move(dx: Int, dy: Int): Point} som skapar en ny punkt på translaterad position enligt delta-koordinaterna \code{dx} och {dy}.

\Subtask Lägg till ett kompanjonsobjekt med medlemmen \code{val origin} som ger en punkt i origo.

\Subtask Undersök metoderna \code{==}, \code{equals} och \code{eq} och förklara vad som händer nedan:
\begin{REPL}
scala> Point(1, 2) == Point(1, 3)
scala> Point(1, 2) == Point(1, 2)
scala> Point(1, 2) equals Point(1, 3)
scala> Point(1, 2) equals Point(1, 2)
scala> Point.origin.move(1, 1) equals Point.origin.move(1, 1)
scala> Point.origin.move(1, 1).move(1,1) == Point(2, 2)
scala> Point(0, 0) eq Point(0, 0)
scala> Point.origin eq Point.origin
scala> val p1 = Point(0,0)
scala> val p2 = p2
scala> p1 eq p2
\end{REPL}

\Subtask Vad ger \code{Point.origin eq Point.origin} för resultat om \code{origin} iställed  implementeras som \code{def origin: Point = Point(0, 0)}

\Subtask\Pen Vad är det för skillnad på strukturlikhet och referenslikhet?

\begin{CodeSmall}
// kod till facit
case class Point(x: Int, y: Int) {
  def distanceTo(that: Point): Double = math.hypot(that.x - x, that.y -y)
  
  def distanceTo(x: Int, y: Int): Double = distanceTo(Point(x, y)) 
  
  def move(dx: Int, dy: Int): Point = Point(x + dx, y + dy)
}

object Point {
  val origin: Point = Point(0, 0)
}
\end{CodeSmall}


\Task Ändra representationen av positionen i klassen \code{Square} från deluppgift \ref{task:Square} till att vara en \code{Point} från deluppgift \ref{task:Point}.


\Task \label{task:PointTuple} \emph{Case-klassen \code{Point} med 2-tupel.} I ett utvecklingsprojekt vill man ändra representationen av positionen i den gamla klassen  \\ \code{case class Point(x: Int, y: Int)} så att positionen istället i den uppdaterade klassen representeras av en 2-tupel. Man kan då vid konstruktion utnyttja att n-tupler som parameter även kan skrivas som en parameterlista med n argument, varför både \code{Point(1,2)} och \code{Point((1,2))} fungerar fint. Samtidigt vill man att befintlig kod som fortfarande använder \code{x} och \code{y} ska fungera utan ändringar.  Implementera den nya \code{Point} enligt specifikationen nedan. 
\begin{ScalaSpec}{Point}
/** A 2-dimensional immutable position p in an integer coordinate system */ 
case class Point(p:(Int, Int)) {
  /** The x-axis position of this Point */
  val x: Int = ???

  /** The y-axis position of this Point */
  val y: Int = ???

  /** The distance to another Point that */
  def distanceTo(that: Point): Double = ???

  /** The distance to another 2-tuple that representing (x, y). */
  def distanceTo(that: (Int, Int)): Double = ???

  /** A new Point that is moved (dx, dy) */
  def move(dxdy: (Int, Int)): Point = ???
}

object Point {
  /** A Point object at position (0, 0) */ 
  val origin: Point = ???
}
\end{ScalaSpec}

\begin{CodeSmall}
// kod till facit
case class Point(p:(Int,Int)) {
  val x: Int = p._1
  
  val y: Int = p._2
  
  def distanceTo(that: Point): Double = 
    math.hypot(that.x - x, that.y -y)
  
  def distanceTo(that: (Int, Int)): Double = 
    distanceTo(Point(that)) 
  
  def move(dx: Int, dy: Int): Point = Point(x + dx, y + dy)
}

object Point {
  val origin: Point = Point(0, 0)
}
\end{CodeSmall}

\Task\Pen Vad behöver du ändra i klassen \code{Square} från deluppgift \ref{task:Square} för att den ska funkera med en \code{Point} med 2-tuple-position från deluppgift \ref{task:PointTuple}?




\ExtraTasks %%%%%%%%%%%%%%%%%%%

\Task \emph{Klassen \code{Frog}} 

\Subtask 

\begin{ScalaSpec}{Frog}
class Frog(startX: Int, startY: Int) {

  def jump(dx: Int, dy: Int): Unit = ???

  def x: Int = ??? 
  
  def y: Int = ???
 
  def randomJump: Unit = ???
  
  def distanceToStart: Double = ???
  
  def distanceJumped: Double = ???
}

\end{ScalaSpec}

\AdvancedTasks %%%%%%%%%%%%%%%%%

\Task     
    