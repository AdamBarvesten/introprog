
%!TEX root = ../compendium.tex

\Exercise{\ExeWeekFOUR}

\begin{Goals}
\item 
\end{Goals}

\begin{Preparations}
\item 
\end{Preparations}

\BasicTasks %%%%%%%%%%%%%%%%

\Task \emph{En enkel datastruktur: tupel.} Du kan samla flera värden i en tupel. Du kommer åt värdena med en metod som har namnet understreck följt av ordningsnumret.
\begin{REPL}
scala> val namn = ("Pippi", "Långstrump")
scala> namn._1
scala> namn._2
scala> println("Förnamn: " + namn._1 + "\nEfternamn:" + namn._2)
\end{REPL}

\Subtask Definiera en oföränderlig variabel med namnet \code{pt} som representerar en punkt med x-koordinaten 15.9 och y-koordinaten 28.9. Använd sedan \code{math.hypt} för att ta reda på avståndet från origo till punkten. Vad blir svaret?

\Subtask Du kan dela upp en tupel i sina beståndsdelar så här:
\begin{REPL}
scala> val (förnamn, efternamn) = ("Ronja", "Rövardotter")
\end{REPL}
Dela upp din punkt \code{pt} i sina beståndsdelar och kalla delarna \code{x} och \code{y}

\Subtask Värdena i en tupel kan ha olika typ. 
\begin{REPL}
scala> val creature = ("Doktor", "Krokodil", 65.0, false)
scala> val (title, name, weight, isHuman)  = creature
\end{REPL}
Vilken typ har 4-tupeln \code{creature} ovan?

\Subtask \label{subtask:tuplecoll} Tupler kan ingå i samlingar.
\begin{REPL}
scala> val pts = Vector((0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)) 
scala> pts.foreach(println)
\end{REPL}
Vilken typ har vektorn \code{pts} ovan?

\Subtask Funktioner kan ta tupler som parametrar.
\begin{REPL}
scala> def length(pt: (Double, Double)) = math.hypot(pt._1, pt._2) 
scala> length((3.0, 4.0))
scala> length(3.0, 4.0)    //kompilatorn lägger till parenteserna innan anrop
\end{REPL}
Applicera funktionen \code{length} ovan på alla tupler i samlingen pts från uppgift \ref{subtask:tuplecoll} med \code{map}. Vad får resultatet för värde och typ?

\Subtask Funktioner kan ge tupler som resultat.
\begin{REPL}
scala> def div(a: Int, b: Int) = (a / b, a % b)
scala> div(10, 3)
scala> (div(9,2), div(10,2))
scala> (div(9,2)._2, div(10,2)._2)
scala> val nOdd = (1 to 10).map(i => div(i, 2)._2).sum
\end{REPL}
Förklara vad som händer ovan. Använd \code{div} ovan för att ta reda på hur många udda tal finns det i intervallet $[1234, 3456]$.

\Task Objekt med attribut (fält). Ett objekt kan samla data som hör ihop. Data i ett objekt kallas \emph{attribut} eller \emph{fält}, \Eng{field}. Objekt som samlar data kallas ibland \emph{post} \Eng{record}.
\begin{REPL}
scala> object mittKonto { var saldo = 0; val nummer = 12345L }
\end{REPL}
\Subtask Skriv en sats som sätter in ett slumpmässigt belopp mellan 0 och en miljon på kontot. 

\Subtask Vad händer om du försöker ändra attributet \code{nummer}?

\Task Klass med attribut. Om man vill kunna ha flera upplagor av ett objekt av samma typ, kan man använda en klass. Man skapar nya objekt med \code{new}.
\begin{REPL}
scala> class Konto(var saldo: Int, val nummer: Long)
scala> val k = new Konto(0, 12345L)
scala> println("Konto: " + k.nummer + " Saldo:" k.saldo)
scala> println(k)
scala> k.toString
\end{REPL}
\Subtask Den två sista raderna ovan skriver ut den identifierare som JVM använder för att hålla reda på objektet i minnet. Skapa ännu en instans av klassen Konto  med samma saldo och nummer som \code{k} ovan och spara den i \code{val k2} och undersök dess objektidentifierare. Får objekten \code{k} och \code{k2} olika objektidentifierare?

\Subtask Vad händer om du försöker ändra attributet \code{nummer}?

\Subtask\Pen Ibland räcker det fint med en tupel, men ofta vill man ha en klass istället. Beskriv några fördelar med en Konto-klassen ovan jämfört med en tupel av typen \code{(Int, Long)}.


\Task Klass med attribut och metoder.

\Task Föränderlighet och oföränderlighet.

\Subtask Innan du kör nedan kod: Försök lista ut vad som kommer skrivas ut. Rita minnessituationen efter varje tilldelning.

\begin{Code}
println("\n--- Example 1: mutable value assigmnent")
var x1 = 42
var y1 = x1
x1 = x1 + 42
println(x1)
println(y1)
\end{Code}

\Subtask Innan du kör nedan kod: Försök lista ut vad som kommer skrivas ut. Rita minnessituationen efter varje tilldelning.

\begin{Code}
println("\n--- Example 2: mutable object reference assignment")
class MutableInt(private var i: Int) {
  def +(a: Int): MutableInt = { i = i + a; this }
  override def toString = i.toString
}
var x2 = new MutableInt(42)
var y2 = x2
x2 = x2 + 42
println(x2)
println(y2)
\end{Code}

\Subtask Innan du kör nedan kod: Försök lista ut vad som kommer skrivas ut. Rita minnessituationen efter varje tilldelning.

\begin{Code}
println("\n--- Example 3: immutable object reference assignment")
class ImmutableInt(val i: Int) {
  def +(a: Int): ImmutableInt = new ImmutableInt(i + a) 
  override def toString = i.toString
}
var x3 = new ImmutableInt(42)
var y3 = x3
x3 = x3 + 42
println(x3)
println(y3)
\end{Code}

\Subtask\Pen Vad finns det för fördelar med oföränderliga objekt?

\ExtraTasks %%%%%%%%%%%%%%%%%%%

\Task 

\AdvancedTasks %%%%%%%%%%%%%%%%%

\Task     
    