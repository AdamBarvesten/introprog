%!TEX encoding = UTF-8 Unicode

%!TEX root = ../compendium.tex

\Lab{\LabWeekELEVEN}

\begin{Goals}
\item Förstå hur autoboxing fungerar i Java
\item Förstå vad statiska metoder och attribut innebär
\item Förstå skillnad mellan primitiva typer och objekt i listor
\item Kunna byta mellan ArrayLists och Array
\item Kunna hur man läser in från fil
\item Kunna for-sats i Java
\end{Goals}

\begin{Preparations}
\item Scanner
\item ArrayList
\item Statiskt
\item Autoboxing
\item Arv
\item Läs igenom Bakgrunden, Kodstrukturen och alla kommentarer i kodskelettet.
\item Exceptions
\end{Preparations}

\subsection{Bakgrund}
I denna labb skall ni tillverka lthopoly, en variant av det välkända brädspelet Monopol med några simplifieringar. Spelet går ut på att spelarna i tur och ordning slår en tärning, varpå deras pjäs flyttas det antal steg som tärningen visar. 
Beroende på vilken av de tre möjliga ruttyperna spelaren hamnar på sker olika saker:

\begin{itemize}
\item MoveSpace: Om en spelare hamnar på denna ruta slumpas ett kort från högen av MoveCards, varpå spelaren förflyttas antingen framåt eller bakåt det antal steg som kortet anger.Kortets deskriptiva text skrivs även ut i spelfönstret.
\item MoneySpace: Om en spelare hamnar på denna ruta slumpas ett kort från högen av MoneyCards, varpå spelaren antingen förlorar pengar eller vinnar pengar enl. kortet.Kortets deskriptiva text skrivs även ut i spelfönstret.
\item HouseSpace: Om en spelare hamnar här gäller olika saker beroende på rutans två tillstånd. Om spelaren hamnar på en HouseSpace som ingen annan spelare har köpt upp skall spelaren få möjlighet att köpa denna om den har råd. Är det istället så att rutan ägs av en annan spelare den nuvarande spelaren betala hyra till ägaren (hyran är samma som inköpspriset). 
\end{itemize}

\subsection{Kodstruktur}
Klassen GameBoard håller koll på spelets tillstånd.
GameBoard använder sig några sorters hjälpobjekt för att hålla koll på detaljerna kring spelet. 
För varje spelare finns ett Player-objekt håller koll på information gällande den spelaren och GameBoard lagrar dessa in en List<Player>.
De ovannämda ruttyperna implementeras som tre olika subklasser till BoardSpace. GameBoard lagrar dessa i en ArrayList<BoardSpace> som representerar hela spelplanen, där objektens index i listan motsvaras av rutornas position på spelplanen. Första rutan har index 0 och sista rutan på spelplanen har index \code{spaces.size()-1}.
GameBoard har en metod getPossibleActions som returnerar en lista över alla möjliga spelarhandlingar för den nuvarande spelaren. Denna används av mainmetoden för att be användaren välja nästa handling. 
Olika sorters spelarhandlingar representeras av statiska int-variabler i klassen GameBoard. Vid val av handling matar användaren in handlingens siffervärde i konsolen. Varje handling motsvaras då alltid av samma inmatningsvärde för användaren.




Den visuella representationen av spelet sker via konsolfönstret med hjälp av klassen \code{TextUI}. \code{TextUI} är en färdigskriven klass med metoder som gör det enkelt att skriva ut spelplanen och en logg av spelhistoriken i konsolfönstret. Utskriften kan exempelvis se ut såhär:

\begin{REPL}
============================================================

Oskar slog en 2:a!
Oskar drog ett kort: Jädrans! Studiebidraget har sänkts. Förlora 40 SEK
Oskar har avslutat sin runda.
Nästa spelare: Jonas
Jonas slog en 3:a!
Jonas drog ett kort: Det lönade sig att leva på nudlar! Inkassera 50 SEK
Jonas har avslutat sin runda.
Nästa spelare: Valthor
Valthor slog en 5:a!
Grattis, Valthor är nu den stolta ägaren av V-Huset
Valthor har avslutat sin runda.
Nästa spelare: Oskar
Oskar slog en 2:a!
Namn----------------Position----------------------Pengar----
Oskar*              Moroten och piskan(40)        260       
Jonas               ChansRuta                     350       
Valthor             V-Huset [Valthor](45)         255       
------------------------------------------------------------
Välj ett alternativ:

	3. Köp ett hus                   
	5. Avsluta din runda             
	8. Visa standardvyn              
	9. Visa spelplanen               
	0. Avsluta Lthopoly              

============================================================

\end{REPL}

\subsubsection{Färdigimplementerat}

\begin{ScalaSpec}{TextUI}
   /** Prints an ASCII plot of the total amount 
	of money in the game as a function of the turn index*/
  def plotStatistics(x: Buffer[Int]): Unit

  /** Appends the String s to the end of the UI's event log */
  def addToLog(s: String): Unit 

  /** Reprints the current state of the UI using the given
	GameBoard to print the status bar*/
  def updateConsole(board: GameBoard): Unit 

 
  /** Asks the user to select an option from a list of options
    *
    * @param options an Array of tuples of the form (choice, description)
    *                where choice is the number the user should enter to select 
    *                the choice represented by description,
    *                e.g. (0,  "End Game") allows the user to input 0 to end 
    *                the game.
    * @return        the selected choice
    */
  def promptForInput(options: Array[(Int, String)]): Int 

  /** Prints the entire GameBoard */
  def printBoard(board: GameBoard): Unit 

 
\end{ScalaSpec}



\subsubsection{Implementeras Själv}
\begin{JavaSpec}{class Player}
	/** Creates a new player*/
	public Player(String name, int money, int pos);

	/** Returns the players money*/
	public int getMoney() ;

	/** Adjusts the players money*/
	public void adjustMoney(int money);

	/** Returns the players position*/
	public int getPosition();

	/** Returns a string representation of the player*/
	public String toString();

	/** Sets the players position*/
	public void setPosition(int pos) ;

\end{JavaSpec}

\begin{JavaSpec}{class BoardSpace}
    /** Returns a array of int describing possible
      * game actions available while on this space*/
    public abstract int[] getPossibleActions(GameBoard board);

    /** Executes a game action available while on this space*/
    public abstract void action(GameBoard board, int action);

    /** Returns a string representation of this BoardSpace*/
    public abstract String toString();
\end{JavaSpec}

\begin{JavaSpec}{class GameBoard}
    /** Creates a new board ready to play */
    public GameBoard(List<Player> players);

    /** Returns a array of int describing possible game actions */
    public int[] getPossibleActions() ;
    
    /** Checks whether the game is over */
    public boolean isGameOver();
    
    /** Returns the player with the most money */
    public Player getRichestPlayer();

    /** Returns a array with all the players */
    public List<Player> getPlayers();

    /** Returns a list with all the board spaces */
    public List<BoardSpace> getBoardSpaces();

    /** Performs an action for the current player */
    public void doAction(int action);
 
    /** Returns the currently active player */
    public Player getCurrentPlayer();

    /** Returns the boardspace corresponding to the position 
      * of the current player. */
    public BoardSpace getCurrentBoardSpace();

    /** Moves the currently active player adjustments spaces forward.
      * Negative adjustment moves the player backwards*/
    public void moveCurrentPlayer(int adjustment);
    
    /** Returns an ArrayList<Integer> of the players cash balance*/
    public ArrayList<Integer> getStatistics();

    /** String Representation of the GameBoard */
    public String toString() ;
\end{JavaSpec}

\begin{JavaSpec}{class DocumentParser}
	/**Returns a ArrayList of Boardspaces loaded from a file*/
	public static ArrayList<BoardSpace> getBoard();

	/**Returns a array of MoneyCards loaded from file*/
	public static MoneyCard[] getMoneyCards();

	/**Returns a array of MoveCards loaded from file*/
	public static MoveCard[] getMoveCards();
\end{JavaSpec}

\begin{JavaSpec}{class MoneyCard}
    /**Creates a new MoneyCard*/
    public MoneyCard( String description, int money);

    /**Returns the cards money adjustment value*/
    public int getMoney();

    /**Returns the description of why the money is adjusted*/ 
    public String getDescription();
\end{JavaSpec}

\begin{JavaSpec}{class MoveCard}
    /**Creates a new MoveCard*/
    public MoveCard( String description, int positionAdjustment) ;

    /**Returns the position adjustment*/
    public int getPositionAdjustment();

    /**Returns the description of why the position is adjusted*/
    public String getDescription();

\end{JavaSpec}

\subsubsection{Spelregler}

\begin{itemize}
\item Om någon spelare har mindre än 0 SEK kvar skall spelet sluta.
\item Om någon spelare hamnar på en husruta som ägs av en annan spelare måste denne betala ägaren husets hyra i SEK.
\item Om en spelare väljer att ta ett kort skall det värde som påverkas av kortet justeras. För MoveCard innebär detta en förflyttning medan för MoneyCard en ändring av pengar.
\item Spelplanen skall vara cyklisk, d.v.s. att nästa ruta efter sista rutan är den första rutan på spelplanen.
\end{itemize}



\subsection{Obligatoriska uppgifter}

\Task Textfilern moneycards.txt , movecards.txt och board.txt innehåller information som skall nyttjas för att skapa de olika rutorna. För att kunna använda de färdiskrivna textfilerna behöver ni nu skriva en statisk metod för inläsning av data från fil i klassen DocumentParser. Hur ni väljer att läsa in från fil är valfritt,  så länge det går att anropa getBoard() och få en lista av rutor som motsvarar spelplanen. Även klasserna MoveCard och MoneyCard skall implementeras så att det går bra ihop med inläsningen.
För skapa ett File-objekt med informationen från filerna kan följande kod användas:
\newline
\newline
\code{File f = new File(DocumentParser.class.}
\newline
\code{getResource("/moneycards.txt").getFile());}
\newline
\newline
Därefter kan ni använda er av ett scanner-objekt som itererar över Filen för att hämta ut den aktuella informationen.
\noindent
\textbf{Obs!} Se textfilerna moneycards.txt, movecards.txt och board.txt för förståelse för hur inläsningen bör gå till för korten.  Ni kan nyttja metoden .split(String) för att ta dela upp indatan.

\Subtask Implementera klassen MoveCard.

\Subtask Implementera klassen MoneyCard.

\Subtask Implementera metoderna getMoneyCards() och getMoveCards() i DocumentParser.

\Subtask Implementera klassen Player.

\Task I denna uppgift skall de tre olika typerna av spelrutor implementeras, som alla ärver ifrån klassen \code{BoardSpace}. Ni kommer då behöva implementera de tre abstrakta metoderna i BoardSpace i respeketive subklass. Här behöver subklasserna tillgång till spelbrädet då förändringen av speltillståndet sker till störren delen i metoden \code{action} för de olika rutorna. HouseSpace kommer dessutom behöva ett attribut som håller koll på vem som äger rutan, medan MoveSpace och MoneySpace kommer behöva tillgång till vektorer av de kort som läses in.

\Subtask Implementera en klass för varje typ av spelruta. Tänk på att MoveSpace och MoneySpace behöver tillgång till respektive kortlekar.
För att skriva metoden action kommer ni behöva nyttja att klassen \code{GameBoard} har statiska variabler som representerar de olika spelarvalen.
\newline
\newline
\noindent
\textbf{Obs!} Än så länge kommer logiken inte fungera då inga metoder är implementerade i BoardGame, det går trots detta bra att anropa metoderna utan kompileringsfel (i väntan på att de implementeras).



\Task Nu är det dags att implementera getBoard() i klassen \code{DocumentParser}. I denna metod skall ni läsa in från filen board.txt och nyttja de metoder ni redan skrivit för att nu kunna skapa MoveSpaces och MoneySpaces. Viktigt här är att ordningen i vilken de olika rutorna är representerade i textfilen spelar roll, då den utgör upplägget av spelplanen. Alltså, beroende på vilken ruta som läses in från textfilen skall motsvarande objekt som representerar denna ruta konstrueras och läggas till i en ArrayList<BoardSpace> som slutligen returneras.


\Subtask Implementera getBoard().
\newline
\newline
\textbf{Fundera på}
\begin{itemize}
\item Behöver flera objekt skapas av varje ruttyp?
\end{itemize}

\Task För att kunna skriva ut och visa spelplanen använder sig klassen \code{TextUI}  av metoden toString() i klassen \code{GameBoard}. Denna ger en textrepresentation av spelplanen. Övriga metoder i klassen \code{GameBoard} skall nu implementeras, nyttja att  \code{TextUI} har metoder för att lägga till utskrifter i olika kolumner för utskrifter av händelser. Det skall inte förekomma någon direkt utskrift i  \code{GameBoard}, alla utskrifter ska gå via \code{TextUI}. I slutet av varje spelares tur skall dessutom den totala summan av pengar hos alla spelare läggas till i en ArrayList, för att det efter spelets slut skall kunna visas statistik för den totala ekonomin. 

\Subtask Implementera GameBoard.
\newline
\newline
\textbf{Tips:}

\begin{itemize}
\item Ni kan använda privata hjälpmetoder för att underlätta implementeringen.
\item Metoden printStatistics i klassen \code{TextUI} tar en vektor av int-värden som inparameter, vilket är opassande då det underlättar att lagra pengahistoriken i en arrayList (eftersom dess storlek inte är bestämd). Det är därför lämpligt att skriva en metod som flyttar över samtliga Integer-objekt från ArrayList<Integers> till en vektor av primitiva int-värden. Detta fungerar trots att de har olika typer p.g.a. autoboxing. 
\item Tänk på att spelarna skall kunna gå runt spelplanen ett obegränsat antal gånger.
\item Tänk på att dela upp arbetet så att det sker en lämpligt arbetsfördelning inom gruppen, men samarbeta så att ni vet hur era olika implementationer interagerar.
\item Glöm inte att skicka strängar till  \code{TextUI} för att generera utskrift när uppdatering sker.
\end{itemize}

\textbf{Fundera på}
\begin{itemize}
\item Varför tar konstruktorn i GameBoard emot en List<Player> istället för en ArrayList<Player>?
\end{itemize}

\Task Med spelplanen implementerad behövs en main-metod för att kunna starta spelet. I mainmetoden skapas GameBoard och alla Spelare. Spelet körs sedan som en loop där GameBoarden tillfrågas vilka spelarhandlingar som är tillåtna för den nuvarande spelaren, erbjuder spelaren möjligheten att välja något av dessa alternativ, och matar sedan in spelarens val tillbaka till GameBoard som hanterar valet. GameBoard ska alltså hantera all spellogik internt.  Spelloopen skall köras tills dess att spelet är över enligt GameBoard.isGameOver.

\Subtask Implementera getAction i Scala. Metoden ska anropa TextUI.promptForInput med en lämplig lista av tupler för att begära input från användarna. Metoden skall nyttja de statiska variablerna från GameBoard för att ge en lämplig utskrift.

\Subtask Implementera main-metoden i Scala.




\subsection{Frivilliga extrauppgifter}

\Task Här är det dags att utöka spelet för att ge utökad funktionalitet som liknar det riktiga spelet.

\Subtask Implementera funktionalitet för att varje spelare ska få extra pengar då den passerar första spelrutan.

\Subtask Implementera funktionalitet för att varje spelare som hamnar på en ruta de äger sedan tidigare har möjlighet att öka hyran för rutan ifall någon annan spelare skulle hamna på den.

\Subtask Implementera funktionalitet för att spelarna själva måste betala en femtedel värdet av sina hus varje runda (varje gång de passerar ett varv på brädet).
    
