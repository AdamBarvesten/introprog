%!TEX encoding = UTF-8 Unicode

%!TEX root = ../compendium.tex


\Lab{\LabWeekFOUR}

\begin{Goals}
\item Kunna använda utvecklingsmiljön Eclipse och dess ScalaIDE.
\item Kunna använda \code{case classer} för att spara data.
\item Kunna spara data till fil.
\item Kunna l{\"a}sa in data fr{\aa}n fil med \code{scala.io}.
\item Kunna skapa och använda klasser för att behandla data.
\item Kunna använda samlingstyperna vektor och map.
\item Kunna flytta data från en samlingstyp till en annan.
\item Förstå skillnaden mellan kompileringsfel och exekveringsfel.
\item Kunna felsöka (små) program med hjälp av utskrifter och debuggern i Eclipse.

%\item Att spara objekt till fil.
%\item Att l{\"a}sa in objekt fr{\aa}n en fil.
\end{Goals}

\begin{Preparations}
\item Gör övning \ref{exe:W02} och \ref{exe:W04}. \emph{Det är livsnödvändig kunskap för en pirat!}
\item Läs om Eclipse i Appendix.
\item Läs igenom laborationen och gör förberedelseuppgiften.
%\item {\"O}ppna Scala IDE i Eclipse enligt intruktionerna XX.
%\item Skapa ett projekt och skapa ett \code{object Hello} med en \code{main}-metod enligt XY.
%\item Skriv ut en h{\"a}lsning till terminalen med \code{println("...")} och testk{\"o}r programmet genom att markera filnamnet i projektmenyn och trycka p{\aa} den gr{\"o}na pilen. Kontrollera att h{\"a}lsningen skrivs ut!
\end{Preparations}


\subsection{Förberedelseuppgifter}

I resterande delen av kursen kommer vi använda utvecklingsmiljön Eclipse med ScalaIDE. Programmet är installerat på studentdatorerna och det är valfritt att installera det på privata datorer, se instruktionerna i \ref{appendix:ide:eclipse:install}. 

Följ instruktionerna i \ref{appendix:ide:eclipse:use} och gör följande: starta Eclipse med ScalaIDE, bekanta dig med utvecklingsmiljön genom att skapa och exekvera ett program som skriver ut en pirathälsning samt ladda hem kursens \emph{workspace} som innehåller kodskelett för laborationerna och importera koden för laborationen \emph{pirates} till Eclipse. 

%\Task Ladda hem zip-filen med kursens workspace från git-repot (XX) och packa upp det på valfritt ställe på din dator. Starta programmet Eclipse och följ instruktionerna i figurer för att skapa ett program och exekvera det.

%Prova att stava fel till \code{println}, då dyker det upp ett rött kryss till vänster på samma kodrad som berättar vad du gjort för fel. Kompilatorn kör i bakgrunden och innan koden kan exekveras måste alla kompileringsfel åtgärdas. Men betyder detta att programmet alltid kommer bete sig korrekt under körningen?


\subsection{Obligatoriska uppgifter}
Efter en rad olyckliga omständigheter har du blivit pirat i 1700-talets Karibien. Nu beh{\"o}ver du undvika galgen och f{\"o}rs{\"o}ka f{\"o}rutse dina f{\"o}r{\"a}diska skeppskamraters n{\"a}sta steg, naturligtvis utan att \emph{din} lojalitet ifrågasätts. 

\Task \emph{Save your crew}. 
I denna deluppgift ska du steg-för-steg fylla i kodskelettet i filen SaveCrew.scala:

\begin{CodeSmall}
package pirates

object SaveCrew {
  	def main(argh: Array[String]): Unit = {
  	  	// change this code to your tests!
  	  
		val filename = if(!argh.isEmpty) argh(0) else "crew.txt"
	}
  	
  	def saveCrew(fileName:String): Unit = ??? 
	// add code for asking the user for crew members and save them to file
  	
	 def readCrew(fileName: String): Unit = ??? 
	 // add code for reading the crew from the file
}
// Help functions. 
object Utils{
// Usage: Utils.write("Blah blah blah", "blahFile.txt")
  def write(s: String, fileName: String): Unit = {
			import java.nio.file.{Paths, Files, StandardOpenOption}
			Files.write(Paths.get(fileName), s.getBytes("UTF-8"))
  } 
  
// Usage: val v = Utils.readLines("minFil.txt")
  def readLines(fileName: String): Vector[String] = {
			scala.io.Source.fromFile(fileName)("UTF-8").getLines.toVector
	}		
  

// Usage: val w = Utils.readWords("minFil.txt")
	def readWords(fileName: String): Vector[String] = {
			scala.io.Source.fromFile(fileName)("UTF-8").getLines.
			map(_.replaceAll("[^a-zA-ZåäöÅÄÖ\\s]", " ")).map(_.toLowerCase()).
			flatMap(_.split("\\s+")).filter(!_.isEmpty).toVector
	}
}

// Add your case class here!

\end{CodeSmall}


\Subtask Kung George {\"a}r villig att ben{\aa}da {\bf fem} personer ur din bes{\"a}ttning! 

Vi ska skapa en lista (nåja, vektor) d{\"a}r personerna sparas med f{\"o}rnamn, efternamn och befattning genom att l{\"a}sa in dem fr{\aa}n konsolen i Eclipse. 

Börja med att implementera en \code{case class CrewMember} med förnamn, eftersnamn och befattningen.

\Subtask Inl{\"a}sning från konsolen i Eclipse g{\"o}rs med \code{scala.io} med kodraden: 
\begin{Code}
val first = scala.io.StdIn.readLine("Förnamn: "). 
\end{Code}

Skriv funktionen \code{saveCrew} som läser in namn och befattning på dina fem besättningsmedlemmar och sparar dem i en {\bf vektor}. \emph{Hint}: du kan spara undan värdet från en for loop till en vektor direkt med hjälp av \code {yield} så här 
\begin{CodeSmall} 
val crew = for(...) yield { 
... // lines to read input from user
	CrewMember(...) // this will be an element in the vector!
}
\end{CodeSmall}


\Subtask Vi vill skriva besättningen till en fil så att den faktiskt sparas. Till din hjälp får hjälpobjektet \code{Utils} med funktionen \code{write} som tar en sträng \code{s} och sparar den till en fil \code{fileName}. Lägg till kodrader i \code{saveCrew} så att vektorn görs om till en sträng och sparas till filen \emph{crew.txt}. \emph{Hint}: samlingsklasser har metoden \code{mkString("\n")} som skapar en sträng av innehållet där varje element separeras med en radbrytning. Använd F5 för att uppdatera projektet så att filen dyker upp i Eclipse.



\Subtask Det går att överskugga \code{toString()} i \code{CrewMember} och på så sätt ändra utskriften genom att lägga till följande kodrad inne i klassen: 
\begin{Code}
override def toString(): String = ??? // add your code here. 
\end{Code}

\noindent Ändra utskriften så att den blir {\em snygg}, t ex med komma\\ 

\noindent Jack Sparrow, kapten \\
Anne Bonny, mordlysten matros \\
Ed Kenway, lönnmördare \\
... 

%\newpage
\Task{Avlusa din besättning.}

\Subtask Din moraliska kompass hindrar dig inte från att också jobba för kung George. Hjälp honom att läsa listan!

En fil \code{fileName} kan läsas rad för rad till en vektor med strängar (en för varje rad) med följande kod som också finns i objektet \code{Utils}: 

\begin{CodeSmall}
// Usage: Utils.readLines("minFil.txt")
def readLines(fileName: String): Vector[String] = {
			scala.io.Source.fromFile(fileName)("UTF-8").getLines.toVector
	}
\end{CodeSmall}
Fyll i koden i \code{readCrew} som läser in besättningen från filen och skapar en \code{CrewMember} för varje rad. Skriv ut personen till konsolen för att se om det blev korrekt.\emph{Hint}: strängar har många metoder, t ex kan man ersätta alla komman med mellanslag med funktionen \code {replace(",", "")}, separera med hjälp av \code{split} och \code{drop(2)} som ger en ny vektor utan de två första elementen.

\Subtask Ändra i \code{main} för att testa att din besättning läses in från filen och skriv ut dem i konsolen. Stämmer det med filinnehållet? använd debuggern  för att hitta fel.

\Subtask Den konkurrerande kaptenen Charles Vane\footnote{hängd för sjöröveri i Port Royal 1721.} betalar dig för att sabotera listan genom att lägga till nonsensrader i filen. Gör det. Vad händer då när du exekverar ditt testprogram?

\Subtask Lägg till några lämpliga if-satser i \code{readCrew} så att en korrekt formaterad rad skapar en \code{CrewMember} medan felaktiga rader skriver ut felmeddelande. 
Testa ditt nya program och se om det blir som förväntat genom lämpliga brytpunkter och utskrifter. Går det att lura ditt program (det är OK)?

\Task{Lögner, förbannade lögner och statistik.}\\
\noindent \\
För att du inte ska bli överlistad av dina sluga, lögnaktiga skeppskamrater behöver du kunna gissa hur en pirat tänker. Därför förkovrar du dig i Robert Louis Stevensons \emph{Skattkammarön}\footnote{Vars copyright har gått ut så du behöver inte piratkopiera den.} som finns i filen \emph{skattkammaron.txt} i workspacet.  Genom att för varje ord spara det mest frekventa nästkommande ordet går det att förutse vad som kommer sägas\footnote{Detta används till exempel i Swiftkey på smarttelefoner.}. 

Kodskelettet vi ska fylla ut finns i objektet \code{PirateSpeech} och ser ut som nedan:
\begin{CodeSmall}
package pirates

object PirateSpeech {
  	def main(argh: Array[String]): Unit = {
			val filename = if(!argh.isEmpty) argh(0) else "skattkammaron.txt"
			// add your tests here!!!

	}
  	
	def readBook(bookFile: String): Unit = ???
	
  /* Optional */
	def readBook(bookFile: String, saveToFile: String): Unit = ???
  
  
  /* Optional */
	def testSpeech(file: String): Unit = ???
	 
  
  class FrequencyCounter(word: String){
	  
	  import scala.collection.mutable.Map
	  
	  // add your code here
	  
	  def addWord(other: String): Unit = ??? 
 	  
	  def getBestGuess(): (String, Int) =  ???
	  
	  override def toString(): String = ???
	}
}
\end{CodeSmall}

Det finns en tom klass \code{FrequencyCounter} som för varje ord ska räkna antalet förekomster av möjliga nästkommande ord (sådana ordpar kallas bigram). I vårt program ska varje ord få en egen \code{FrequencyCounter} som i sin tur innehåller en samling, i vårt fall en föränderlig \code{Map} med ord och antal som nyckel-värde-par. Ditt uppdrag är att steg-för-steg implementera \code{FrequencyCounter}, räkna bigram i \emph{Skattkammarön} och skriva ett program för att gissa pirat-prat. 


\code{FrequencyCounter} ska fungera såhär: I texten förekommer ordkombinationerna \emph{och de}, \emph{och jag}, \emph{och återvänder} och lite senare \emph{och jag} igen. Vi skapar en \code{FrequencyCounter} för \emph{och} och lägger till \emph{de}, \emph{jag}, \emph{återvänder} och \emph{jag} och sen ska den bästa gissningen för \emph{och} vara \emph{jag} med antalet 2. 


\Subtask Lägg till ett \code{Map}-attribut i \code{FrequencyCounter} för att spara ord (strängar) och antal. Tänk på att välja ett lämpligt namn på attributet. \emph{Hint}: Typerna i en \code{Map} anges inom hakparenteser \code{Map[String, Int]()}. 

\Subtask När vårt \code{Map}-attribut skapas är den tom. Implementera funktionen \code{addWord} i \code{FrequencyCounter} som räknar upp antalet förekomster av ett visst ord. Om det är första gången ordet förekommer behöver det läggas in i samlingen med antalet 1. \emph{Hint}: Samlingar har funktionen \code{contains} för att se om ett element finns i den och värden både uppdateras och returneras genom att använda nyckeln inom parentes.

\Subtask Implementera funktionen \code{getBestGuess} som returnerar en tuppel med bästa gissning och hur ofta den förekommer. Detta kan vi göra på olika sätt, t~ex genom att gå igenom alla tuppler i vår \code{Map} och spara undan den med högst \emph{värde} (se uppgift 12 i övning 2), men en lat pirat använder den färdiga samlingsfunktionen \code{maxBy} för att jämföra tupplernas värden. I en \code{Map} \emph{wordCounter} används det såhär: \code{wordCounter.maxBy(tuple => tuple._2)} som för varje nyckel-värde-par \emph{tuple} bara jämför \emph{värdet} som hämtas med \code{_2}. Det går att skriva samma sak superkort \code{wordCounter.maxBy(_._2)}.

\Subtask Implementera \code{toString} som returnerar ordet (\code{word}) samt den bästa gissningen och hur ofta den förekom. 

\Subtask Testa din klass genom att lägga till kodrader i \code{main} för att skapa en \code{FrequencyCounter} för ett ord, lägg till data med \code{addWord} och avsluta med att skriva ut resultatet. Använd t ex  \emph{och}-exemplet ovan.

\Subtask Nu är det dags att implementera funktionen \code{readBook}. Konceptuellt vill vi göra följande: 1) läsa in all data från textfilen med boken till en vektor med ord, 2) få ut en samling unika ord så att vi kan 3) skapa en \code{FrequencyCounter} för varje ord och slutligen, 4) gå igenom hela boken och räkna ordpar (bigrammen).  
\noindent
Du får följande ledtrådar: 

\begin{enumerate}
\item \code{Utils.readWords} är en funktion för att läsa in ord från en fil med hjälp av \code{scala.io.Source.fromFile}. Funktionen tar bort allt som {\em inte} är svenska bokstäver och separerar orden med hjälp av \code{split} på mellanslag samt gör om alla tecken till gemener. 

\item Samlingsklassen \code{Set} tillåter bara unika element, så om man skapar ett tomt Set (\code{... = Set()}) och sen lägger till sina ord med \code{++}  filtreras dubbletter bort. 

\item Spara räknaren för varje ord i en \code{Map[String, FrequencyCounter]} där ordsträngen och räknaren är sparade som nyckel-värde-tuppler. Använd funktionen \code{map} på setet för att för varje ord \code{word} skapa en tuppel med en ny räknare (\code{word -> new FrequencyCounter(word)}). Resultatet från funktionen \code{map} för samma typ som ursprungssamlingen, den kan omvandlas till en map genom att anropa \code{toMap}!

\item I Övn \ref{exe:W02} lärde vi oss att iterera genom en vektor med \code{for(word <- words)} men nu vill vi få två ord i taget! Vektor-funktionen \code{sliding(2)} ger en minivektor av storlek 2 som vi kan använda för att iterera över ordpar: 
\begin{Code} 
for(pair <- words.sliding(2)) { ... } 
\end{Code}.

\item När vi har ett ordpar med två ord, \code{first} och \code{second}, behöver vi plocka fram räknaren för \code{first} från vår \code{Map} som i sin tur sköter uppräkningen av ordet \code{second} i \code{addWord}. 

\end{enumerate}

\Subtask Testa att ditt program genom att lägga till kodrader längst ner i funktionen \code{readBook} (och i \code{main}) som skriver ut några gissningar, t ex vad kommer troligtvis efter ''och'' respektive ''jim''? 
\newline
\newline
\noindent
\emph{Du blir så bra på tankeläsning att dina skeppskamrater anklagar dig för svart magi och din sjörövarhistoria slutar en stormig natt med att du sveps över bord under mystiska omständigheter.}


\subsection{Frivilliga extrauppgifter}
Det tar lång tid att läsa in hela boken och räkna alla frekvenser \emph{varje} gång programmet körs. Eftersom boken inte ändras kan du spara resultatet från uträkningen till en fil och bara läsa in \emph{resultatfilen}, dvs, efter att du skrivit \code{readBook} kan du spara varje ord tillsammans med den bästa gissningen till en fil. Sen kan du testa programmet genom att läsa in dessa par ...

\Subtask Fyll i funktionen 
\begin{CodeSmall}
def readBook(bookFile: String, saveToFile: String)} 
\end{CodeSmall}
så att den, utöver det som din gamla funktion gör, också skapar en sträng där varje rad innehåller ett ord samt dess bästa gissning och sen sparar strängen till filen \code{saveToFile}. Kontrollera att utskriften till filen ser OK ut. 

\Subtask Skriv funktionen \code{testSpeech(savedFile: String)} så att den läser in raderna från din sparade fil med \code{Utils.readLines}. Ordet och gissningen ska sparas i en \code{Map[String, String]}.  Testa slutligen ditt program med några väl valda ord.

\emph{Hint}: dela upp strängen på ord med hjälp av \code{split(...)}. Kom ihåg att det går att generera samlingar direkt med hjälp av en forloop \begin{CodeSmall}
val s = for(...) yield{
...
// element
}

\end{CodeSmall} 
Vilken samlingstyp blir resultatet? I labben lärde du dig två sätt att konvertera mellan olika typer av samlingar, antingen kan du skapa en tom samling  och lägga in elementen med \code{++} eller anropa konverteringsfunktioner som \code{toMap}. 
 

%\Subtask En underuppgift.

%\Subtask En underuppgift.
    
