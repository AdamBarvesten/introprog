%!TEX encoding = UTF-8 Unicode

%!TEX root = ../compendium.tex

\Exercise{\ExeWeekEIGHT}

\begin{Goals}
\item 
\end{Goals}

\begin{Preparations}
\item 
\end{Preparations}

\BasicTasks %%%%%%%%%%%%%%%%

\Task \label{task:switch} \emph{Hur funkar en \jcode{switch}-sats i Java?} Ibland vill man testa om ett värde kan vara ett av många  olika alternativ och då kan man använda en sekvens av \code{if}-\code{else}, men det finns ett annat alternativ: i Java och många andra språk finns en \jcode{switch}-sats kollar flera alternativ i en sats, se t.ex. \href{https://en.wikipedia.org/wiki/Switch_statement}{en.wikipedia.org/wiki/Switch\_statement}.

\Subtask Skriv in nedan kod i en kodeditor. Spara med namnet \texttt{Switch.java} och kompilera filen med kommandot \texttt{javac Switch.java}. Kör den med \texttt{java Switch} och ange din favoritgrönsak som argumnet till programmet. Vad händer? Förklara hur \jcode{switch}-satsen fungerar.

\javainputlisting[numbers=left,basicstyle=\ttfamily\fontsize{11}{12}\selectfont]{examples/Switch.java}

\Subtask \label{subtask:break} Vad händer om du tar bort \jcode{break}-satsen på rad 15?



\Task \emph{Matcha värden.} I Scala finns ingen \jcode{switch}-sats. I stället har Scala ett \code{match}-uttryck som är mer kraftfullt. Dock saknar Scala nyckelordet \jcode{break} och Scalas \code{match}-uttryck kan inte ''falla igenom'' som skedde i uppgift \ref{task:switch}\ref{subtask:break}.

\Subtask Skriv nedan program med en kodeditor och spara i filen \texttt{Match.scala}. Kompilera med \texttt{scalac Match.scala}. Kör med \texttt{scala Match} och ge som argument din favoritgrönsak. Vad händer? Förklara hur ett \code{match}-uttryck fungerar.

\scalainputlisting[numbers=left,basicstyle=\ttfamily\fontsize{11}{12}\selectfont]{examples/Match.scala}


\Subtask\Pen Beskriv några skillnader i syntax och semantik mellan Javas flervalssats \jcode{switch} och Scalas flervalsuttryck \code{match}.


\Task \emph{TODO Villkor i match-grenar.} \Eng{guards} \code{if math.random > 0.5} 

\Task \emph{TODO Matcha på case-klasser.}  

\Task \emph{TODO matcha på case-objekt. Nyttan med sealed.} Ska detta vara fördjupning??

\Task \emph{TODO Matcha på Option.}  

\Task \emph{TODO Fånga undantantag i Java} Integer.parseInt

\Task \emph{TODO Fånga undantantag i Scala med \code{try}.} Integer.parseInt

\Task \emph{TODO Fånga undantantag i Scala med \code{scala.util.Try}.} Integer.parseInt  

\Task \emph{TODO flatten och flatMap med Option och Try}

\Task \emph{TODO partiella funktioner och metoden collect på samlingar} TODO Ska detta vara fördjupning???


\Task \emph{Överskugga metoden \code{equals}}  Om man överskuggar den befintliga metoden \code{equals} så kommer metoden \code{==} att fungera annorlunda. Vi börjar att studera den befintliga equals med referenslikhet.

\begin{REPL}
scala> class Gurka(val vikt: Int)
scala> val g1, g2 = new Gurka(42)
scala> val g3 = new Gurka(42)
scala> g1 == g2
scala> g1 == g3
scala> g1.equals  // tryck TAB två gånger
\end{REPL}

\Subtask Om du trycker TAB \emph{två} gånger efter ett metodnamn får du se metodens signatur. Vilken signatur har metoden \code{equals}?

\Subtask Byt ut equals enligt nedan och förklara vad som händer.

\begin{REPL}
scala> class Gurka(val vikt: Int) { 
         override def equals(other: Any): Boolean = other match {
           
         } 
scala> val g = new Gurka(42)
scala> g.equals  // tryck TAB två gånger
\end{REPL}



\Task \emph{Klassen \code{Complex} och metoden \code{equals}.} Implementera klassen \code{Complex} som representerar ett komplext tal\footnote{\href{https://sv.wikipedia.org/wiki/Komplexa_tal}{sv.wikipedia.org/wiki/Komplexa\_tal}} med realdel och imaginärdel.

\begin{REPL}
scala> class Complex(val re: Double, im: Double)

\end{REPL}

\ExtraTasks %%%%%%%%%%%%%%%%%%%

\Task 

\AdvancedTasks %%%%%%%%%%%%%%%%%

\Task Överskugga equals vid arv, exempel Shape. Ska detta vara fördjupning???     
    