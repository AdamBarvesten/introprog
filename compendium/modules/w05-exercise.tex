%!TEX encoding = UTF-8 Unicode

%!TEX root = ../compendium.tex

\Exercise{\ExeWeekFIVE}

\begin{Goals}
\item 
\end{Goals}

\begin{Preparations}
\item 
\end{Preparations}

\BasicTasks %%%%%%%%%%%%%%%%

\Task \emph{Variabelt antal argument.} Det går fint att deklarera en funktion som tar en argumentsekvens av godtycklig längd. Syntaxen består ev en asterisk \code{*} efter typen.

\Subtask Vad händer nedan?
\begin{REPL}
scala> def printAll(xs: Int*) = xs.foreach(println)
scala> printAll(42)
scala> printAll(1, 2, 7, 42)
scala> def printStrings(wa: String*) = println(wa)
scala> printStrings("hej","på","dej")
\end{REPL}

\Subtask Vad har parametern \code{wa} i \code{printStrings} ovan för typ?

\Subtask Ändra i \code{printAll} så att även längden på \code{xs} skrivs ut före utskriften av alla element. Testa att anropa \code{printAll} med olika antal parametrar. 

\Subtask Vad händer om du anropar \code{printAll} med noll parametrar?

\Task \emph{Oföränderliga sekvenser med föränderliga objekt.} 

\Subtask Vad får xs för värde efter att attributet i objektet som \code{c2} refererar till ändras på rad 4 nedan? Förklara vad som händer.
\begin{REPL}
scala> class IntCell(var x: Int){override def toString = "[Int](" + x + ")"}
scala> val (c1, c2, c3) = (new IntCell(7), new IntCell(8), new IntCell(9))
scala> val xs = Vector(c1, c2, c3)
scala> c2.x = 42
scala> xs
\end{REPL}

\Subtask\Pen Rita en bild av minnessituationen efter rad 4 ovan.

\Subtask\Pen Vad krävs för att allt innehåll i en oföränderlig samling garanterat ska förbli oförändrat? 

\Task Föränderliga, indexerbara sekvenser: \code{Array} och \code{ArrayBuffer}

\Subtask Samlingen \code{scala.Array} har speciellt stöd i JVM och är extra snabb att allokera och indexera i. Dock kan man inte ändra storleken efter att en Array allokerats. Behöver man mer plats kan man kopiera den till en ny, större array. Koden nedan visar hur det kan gå till.
\begin{REPL}
scala> val xs = Array(42, 43, 44)
scala> val ys = new Array[Int](4)  //plats för 4 heltal, från början nollor
scala> for (i <- 0 until xs.size){ys(i) = xs(i)}
scala> ys(3) = 45
\end{REPL}
Definiera funktionen \code{def copyAppend(xs: Array[Int], x): Array[Int]} som implementerar nedan algoritm, \emph{efter} att du rätta de \textbf{\color{red}{två buggarna}} i algoritmens while-loop:

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}
 
 \Input{Heltalsarray $xs$ och heltalet $x$}
 \Output{En ny array som som är en kopia av $xs$ men med $x$ tillagt på slutet som extra element.}
 $n \leftarrow$ antalet element i $xs$ \\
 $ys \leftarrow$ en ny array med plats för $n + 1$ element\\
 $i \leftarrow 0$  \\
 \While{$i \leq n$}{
  $ys(i) \leftarrow xs(i)$
 }
 $ys(n) \leftarrow x$ 
\end{algorithm}



\Subtask Samlingen \code{scala.collection.mutable.ArrayBuffer} är inte riktigt lika snabb i alla lägen som \code{scala.Array} men storleksändring hanteras automatiskt, vilket är en stor fördel då man slipper att själv implementera algoritmer liknande \code{copyAppend} ovan. Speciellt använder man ofta \code{ArrayBuffer} om man stegvis vill bygga upp en sekvens. Vad händer nedan?
\begin{REPL}
scala> val xs = scala.collection.mutable.ArrayBuffer.empty[Int]
scala> xs.append(1, 2)
scala> while (xs.last < 100) {xs.append(xs.takeRight(2).sum); println(xs)}
scala> xs.last
scala> xs.length
\end{REPL}

\Subtask Talen i sekvensen som produceras ovan kallas Fibonaccital\footnote{\href{https://sv.wikipedia.org/wiki/Fibonaccital}{sv.wikipedia.org/wiki/Fibonaccital}}. Hur lång ska en Fibonacci-sekvens vara för att det sista elementet ska komma så nära (men inte över) \code{Int.MaxValue} som möjligt?



\Task \emph{Kopiering och uppdatering.} Metoder på oföränderliga samlingar skapar nya samlingar istället för att ändra. Därför behöver man inte själv skapa kopior. När en \emph{föränderlig} samling uppdateras på plats, syns denna förändring via alla referenser till samlingen.

\begin{REPL}
scala> val xs = Vector(1, 2, 3)
scala> val ys = xs.toArray
scala> ys(1) = 42
scala> xs
scala> ys
scala> val zs = ys.toArray
scala> zs(1) = 84
scala> xs
scala> ys
scala> zs
\end{REPL}

\Subtask Syns updateringen av objektet som \code{ys} refererar till via referensen \code{xs}? Varför?

\Subtask Syns updateringen av objektet som \code{zs} refererar till via referensen \code{ys}? Varför? 

\Subtask Syns updateringen av objektet som \code{zs} refererar till via referensen \code{xs}? Varför?

\Task \emph{Färdig metod för att skapa kopia av array.} Om man inte vill att en uppdatering av en föränderlig samling ska få oönskad påverkan på andra koddelar som refererar till samlingen, behöver man göra kopior av samlingen före uppdatering. Det finns färdiga metoder för kopiering av objekt av typen Array i paketet \code{java.util.Arrays}. 

\Subtask\Pen Studera dokumentationen för metoden \code{java.util.Arrays.copyOf} här:\\ \href{https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html\#copyOf-int:A-int-}{docs.oracle.com/javase/8/docs/api/java/util/Arrays.html\#copyOf-int:A-int-} \\
Notera att syntaxen för arrayer i Java är annorlunda: När det står \code{int[]} i Java så motsvarar det \code{Array[Int]} i Scala. Vad används den andra parametern till?

\Subtask\Pen Rita en bild av hur minnet ser ut efter varje tilldelning nedan. Vad har \code{xs}, \code{ys} och \code{zs} för värden efter exekveringen av raderna 1--5 nedan? Varför? 
\begin{REPL}
scala> val xs = Array(1, 2, 3, 4)
scala> val ys = xs
scala> val zs = java.util.Arrays.copyOf(xs, xs.size - 1)
sxala> xs(0) = 42
scala> zs(0) = 84
scala> ys
scala> xs
scala> zs
\end{REPL}

\Task \emph{Algortim: SEQ-REVERSE-COPY.} Implementera nedan algoritm:

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}
 
 \Input{Heltalsarray $xs$ och heltalet $x$}
 \Output{En ny heltalsarray med elementen i $xs$ i omvänd ordning.}
 $n \leftarrow$ antalet element i $xs$ \\
 $ys \leftarrow$ en ny heltalsarray med plats för $n$ element\\
 $i \leftarrow 0$  \\
 \While{$i < n$}{
  $ys(n - i - 1) \leftarrow xs(i)$ \\
  $i \leftarrow i + 1$
 }
 \Return $ys$
\end{algorithm}

\Subtask\Pen Skriv implementation med penna och papper. Använd en \code{while}-sats på samma sätt som i algoritmen. Prova sedan din implementation på dator och kolla så att den fungerar.

\Subtask\Pen \label{subtask:for-seq-copy} Skriv implementationen med penna och papper igen, men använd nu istället en \code{for}-sats som räknar baklänges. Prova sedan din implementation på dator och kolla så att den fungerar. 

\Subtask Definiera en funktion i REPL med namnet \code{reverseCopy} med din implementation i uppgift \ref{subtask:for-seq-copy}.  


\Task \emph{Algoritm: SEQ-REVERSE.} Strängar av typen \code{String} är oföränderliga. Vill man ändra i en sträng utan att skapa en ny kopia kan man använda en \code{StringBuilder} enligt nedan algoritm som vänder bak-och-fram på en sträng. 

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}
 
 \Input{En sträng $s$ av typen \texttt{String}}
 \Output{En ny sträng av typen \texttt{String}}
 $sb \leftarrow$ en ny \texttt{StringBuilder} som innehåller $s$ \\
 $n \leftarrow$ antalet tecken i $s$\\
 $i \leftarrow 0$  \\
 \For{$i \leftarrow 0$ \KwTo $\frac{n}{2} - 1$}{
  $temp \leftarrow sb(i)$ \\
  $sb(i) \leftarrow sb(n - i - 1)$ \\
  $sb(n - i - 1) \leftarrow temp$ \\
 }
 \Return $sb$ omvandlad till en \texttt{String}
\end{algorithm}

\Subtask Implementera algoritmen ovan i en funktion med signaturen: \\
 \code{def reverseString(s: String): String}

\begin{Code}
// Kod till facit:
def reverseString(s: String): String = {
  val sb = new StringBuilder(s)
  val n = sb.length
  for (i <-0 until n / 2) { 
    val temp = sb(i)
    sb(i) = sb(n - i - 1)
    sb(n - i - 1) = temp
  }
  sb.toString     
}
\end{Code}

\Subtask Använd din funktion \code{reverseString} från föregående deluppgift i en ny funktion med signaturen:\\
 \code{def isPalindrome(s: String): Boolean} \\ som avgör om en sträng är en palindrom.\footnote{\href{https://sv.wikipedia.org/wiki/Palindrom}{sv.wikipedia.org/wiki/Palindrom}} 

\Subtask\Pen Man kan med en \code{while}-sats och indexering direkt i en \code{String} avgöra om en sträng är en palindrom utan att kopiera den till en \code{StringBuilder}. Implementera en ny variant av \code{isPalindrome} som använder denna metod. Skriv först algoritmen på papper i pseudo-kod.

\begin{Code}
// Kod till facit:
def isPalindrome(s: String): Boolean = {
  val n = s.length
  var foundDiff = false
  var i = 0
  while (i < n/2 && !foundDiff)  { 
    foundDiff = s(i) != s(n - i - 1)
    i += 1
  }
  !foundDiff
}
\end{Code}

\Task \emph{Algoritm: SEQ-REGISTER.} Algoritmer för registrering löser problemet att räkna förekomst av olika saker, till exempel antalet tärningskast som gav en sexa. Antag att vi har följande vektor \code{xs} som representerar 13 st tärningskast:
\begin{REPL}
scala> val xs =  Vector(5, 3, 1, 6, 1, 3, 5, 1, 1, 6, 3, 2, 6)
\end{REPL}

\Subtask Använd metoderna \code{filter} och \code{size} på \code{xs} för att filtrera ut alla 6:or och räkna hur många de är.

\Subtask Använd metoderna \code{filter} och \code{size} på \code{xs} för att filtrera ut alla jämna kast och räkna hur många de är.

\Subtask Metoden \code{groupBy} på en samling tar en funktion \code{f} som parameter och skapar en ny \code{Map} med nycklar \code{k} som är associerade till samlingar som utgör grupper av värden där 
\code{f(x) == k}.  Vad händer här:
\begin{REPL}
scala> xs.groupBy(x => x % 2)
scala> xs.groupBy(_ % 2)
scala> xs.groupBy(_ % 3)
scala> xs.groupBy(_ % 3).foreach(println)
scala> val freqEvenOdd = xs.groupBy(_ % 2).map(p => (p._1, p._2.size)) 
scala> val nEven = freqEvenOdd(0)
scala> val nOdd = freqEvenOdd(1)
\end{REPL}

\Subtask Använd metoden \code{groupBy} på \code{xs} med den s.k. identitetsfunktionen \code{i => i} som returnerar sitt eget argument. Vad händer? 

\Subtask Definiera en \code{val freq: Map[Int, Int]} som räknar antalet olika tärningsutfall i \code{xs}. Använd metoden \code{groupBy} på \code{xs} med identitetsfunktionen följt av en \code{map} med funktionen \code{p => (p._1, p._2.size)}.

\Subtask Du ska nu själv implementera en registreringsalgoritm. Skriv en funktion:
\begin{Code}
def tärningsRegistrering(xs: Array[Int]): Array[Int] = ???
\end{Code}
som implementerar nedan algoritm (utan att använda \code{groupBy} eller andra färdiga metoder på samlingar förutom \code{size} och \code{apply}).


\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}
 
 \Input{En array $xs$ med heltal mellan 1 och 6 som representerar utfall av många tärningskast.}
 \Output{En array $f$ med 7 st element där $f(0)$ innehåller totala antalet kast, $f(1)$ anger antalet ettor, $f(2)$ antalet tvåor, etc. till och med $f(6)$ som anger antalet sexor.}
 $f \leftarrow$ en ny array med $7$ element där alla element initaliseras till 0.\\
 $f(0) \leftarrow$ antalet element i $xs$ \\
 $i \leftarrow 0$  \\
 \While{$i < f(0)$}{
  $f(xs(i)) \leftarrow f(xs(i)) + 1$ \\
  $i \leftarrow i + 1$
 }
 \Return $f$ 
\end{algorithm}






\Task Keno-dragningar under ett år -> Registrering...

\ExtraTasks %%%%%%%%%%%%%%%%%%%






\AdvancedTasks %%%%%%%%%%%%%%%%%

\Task Studera skillnader och likheter mellan 

\Subtask \code{Array}

\Subtask \code{WrappedArray}  

\Subtask \code{ArraySeq} 

\noindent genom att läsa mer om dessa arrayvarianter här: \\
\href{http://docs.scala-lang.org/overviews/collections/concrete-mutable-collection-classes}{docs.scala-lang.org/overviews/collections/concrete-mutable-collection-classes} \\  
\href{http://docs.scala-lang.org/overviews/collections/arrays.html}{docs.scala-lang.org/overviews/collections/arrays.html}  \\ 
\href{http://stackoverflow.com/questions/5028551/scala-array-vs-arrayseq}{stackoverflow.com/questions/5028551/scala-array-vs-arrayseq}   
    
    
\Task Studera vad metoden \code{java.util.Arrays.deepEquals} gör här:\\
\href{https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#deepEquals-java.lang.Object:A-java.lang.Object:A-}{Arrays.html\#deepEquals-java.lang.Object:A-java.lang.Object:A-} \\
Vad skiljer ovan metod från metoden \code{java.util.Arrays.equals}?
    