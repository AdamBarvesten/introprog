%!TEX root = ../compendium.tex

\Exercise{\ExeWeekTWO}

\begin{Goals}
\item Kunna skapa samlingarna Range, Array och Vector med heltals- och strängvärden.
\item Kunna anropa operationerna size, mkString, sum, min, max på samlingar som innehåller heltal.
\item Känna till grundläggande skillnader och likheter mellan samlingarna Range, Array och Vector.
\item Förstå skillnaden mellan en for-sats och ett for-uttryck.
\item Kunna skapa samlingar med heltalsvärden som resultat av enkla for-uttryck.
\end{Goals}

\begin{Preparations}
\item Studera teorin i kapitel~\ref{chapter:W02}.
\item Bekanta dig med grundläggande terminalkommandon; se appendix~\ref{appendix:terminal}. 
\item Bekanta dig med den editor du vill använda; se appendix~\ref{appendix:edit}.
\end{Preparations}

\BasicTasks %%%%%%%%%%%%%%%%

\Task  \emph{Datastrukturen \code+Range+.} Evaluera nedan uttryck i Scala REPL. Vad har respektive uttryck för värde och typ?

\Subtask \code{Range(1, 10)}

\Subtask \code{Range(1, 10).inclusive}

\Subtask \code{Range(0, 50, 5)}

\Subtask \code{Range(0, 50, 5).size}

\Subtask \code{Range(0, 50, 5).inclusive}

\Subtask \code{Range(0, 50, 5).inclusive.size}

\Subtask \code{0.until(10)}

\Subtask \code{0 until (10)}

\Subtask \code{0 until 10}

\Subtask \code{0.to(10)}

\Subtask \code{0 to 10}

\Subtask \code{0.until(50).by(5)}

\Subtask \code{0 to 50 by 5}

\Subtask \code{(0 to 50 by 5).size}

\Subtask \code{(1 to 1000).sum}


\Task \label{task:array} \emph{Datastrukturen \code+Array+.} Kör nedan kodrader i Scala REPL. Beskriv vad som händer.

\Subtask \code{val xs = Array("hej","på","dej", "!")}

\Subtask \code{xs(0)}

\Subtask \code{xs(3)}

\Subtask \code{xs(4)}

\Subtask \code{xs(1) + " " + xs(2)}

\Subtask \code{xs.mkString}

\Subtask \code{xs.mkString(" ")}

\Subtask \code{xs.mkString("(", ",", ")")}

\Subtask \code{xs.mkString("Array(", ", ", ")")}

\Subtask \code{xs(0) = 42}

\Subtask \code{xs(0) = "42"; println(x(0))}

\Subtask \code{val ys = Array(42, 7, 3, 8)}

\Subtask \code{ys.sum}

\Subtask \code{ys.min}

\Subtask \code{ys.max}

\Subtask \code{val zs = Array.fill(10)(42)}

\Subtask \code{zs.sum}

\Task \emph{Datastrukturen \code+Vector+.} Kör nedan kodrader i Scala REPL. Beskriv vad som händer.

\Subtask \code{val words = Vector("hej","på","dej", "!")}

\Subtask \code{words(0)}

\Subtask \code{words(3)}

\Subtask \code{words.mkString}

\Subtask \code{words.mkString(" ")}

\Subtask \code{words.mkString("(", ",", ")")}

\Subtask \code{words.mkString("Ord(", ", ", ")")}

\Subtask \code{words(0) = "42"}

\Subtask \code{val numbers = Vector(42, 7, 3, 8)}

\Subtask \code{numbers.sum}

\Subtask \code{numbers.min}

\Subtask \code{numbers.max}

\Subtask \code{val moreNumbers = Vector.fill(10000)(42)}

\Subtask \code{moreNumbers.sum}

\Subtask\Pen Jämför med uppgift \ref{task:array}. Vad kan man göra med en \code{Array} som man inte kan göra med en \code{Vector}?

\Task \emph{\code+for+-uttryck}. Evaluera nedan uttryck i Scala REPL. Vad har respektive uttryck för värde och typ?

\Subtask \code{for (i <- Range(1,10)) yield i}

\Subtask \code{for (i <- 1 until 10) yield i}

\Subtask \code{for (i <- 1 until 10) yield i + 1}

\Subtask \code{for (i <- Range(1,10).inclusice) yield i}

\Subtask \code{for (i <- 1 to 10) yield i}

\Subtask \code{for (i <- 1 to 10) yield i + 1}

\Subtask \code{(for (i <- 1 to 10) yield i + 1).sum}

\Subtask \code{for (x <- 0.0 to 2 * math.Pi by math.Pi/4) yield math.sin(x)}


\Task \emph{Metoden \code+map+ på en samling.} Evaluera nedan uttryck i Scala REPL. Vad har respektive uttryck för värde och typ?

\Subtask \code{Range(0,10).map(i => i + 1)}

\Subtask \code{(0 until 10).map(i => i + 1)}

\Subtask \code{(1 to 10).map(i => i * 2)}

\Subtask \code{(1 to 10).map(_ * 2)}

\Subtask \code{Vector.fill(10000)(42).map(_ + 43)}

\Task \emph{Metoden \code+foreach+ på en samling.} Kör nedan satser i Scala REPL. Vad händer?

\Subtask \code{Range(0,10).foreach(i => println(i))}

\Subtask \code{(0 until 10).foreach(i => println(i))}

\Subtask \code|(1 to 10).foreach{i => print("hej"); println(i * 2)}|

\Subtask \code{(1 to 10).foreach(println)}

\Subtask \code{Vector.fill(10000)(math.random).foreach(r => if (r > 0.99) print("pang!"))}


\Task \emph{Algoritm: SWAP.}

\Subtask Beskriv i pseudo-kod algoritmen SWAP: 

\emph{Indata:} två heltalsvariabler $x$ och $y$ 

\emph{???}

\emph{Utdata:} variablerna $x$ och $y$ vars värden har bytt plats.

\Subtask Ersätt \code{???} nedan med satser separerade av semikolon som implementerar algoritmen SWAP.

\begin{REPL}
scala> var (x, y) = (42, 43)
scala> ???
scala> println("x är " + x + ", y är " + y)
x är 43, y är 42
\end{REPL}



\Task \emph{Skript.} Skapa med hjälp av en editor en fil med namn \texttt{hello-script.scala} som innehåller denna enda rad:
\begin{Code}
println("hej skript")
\end{Code}
Spara filen och kör kommandot \code{scala hello-script.scala} i terminalen:
\begin{REPL}
> scala hello-script.scala
\end{REPL}

\Subtask Vad händer?

\Subtask Ändra i filen så att högerparentesen saknas. Spara och kör skriptfilen igen. Vad händer?

\Subtask Lägg till en sats sist i skriptet som skriver ut summan av de ett tusen stycken heltalen från och med 2 till och med 1001, så som visas nedan.
\begin{REPL}
> scala hello-script.scala
hej skript
501500
\end{REPL}

\Subtask Ändra i hello-script.scala genom att införa \code{val n = args(0).toInt} och använd \code{n} som övre gräns för summeringen av de n första heltalen.
\begin{REPL}
> scala hello-script.scala 5001
hej skript
12507501
\end{REPL}

\Subtask Vad blir det för felmeddelande om du glömmer ge programmet ett argument?


\Task \emph{Applikation med \code+main+-metod.} Skapa med hjälp av en editor en fil med namn \texttt{hello-app.scala}.
\begin{REPL}
> gedit hello-app.scala
\end{REPL}
Skriv dessa rader i filen:


\scalainputlisting{examples/hello-app.scala}

\Subtask Kompilera med \code{scalac hello-app.scala} och kör koden med \code{scala Hello}.
\begin{REPL}
> scalac hello-app.scala
> ls
> scala Hello
\end{REPL}
Vad heter filerna som kompilatorn skapar?

\Subtask Ändra i din kod så att kompilatorn ger följande felmeddelande: \\
\texttt{Missing closing brace}

\Subtask\Pen Varför behövs \code{main}-metoden?

\Subtask\Pen Vilket alternativ går snabbast att köra igång, ett skript eller en kompilerad applikation? Varför? Vilket alternativ kör snabbast när väl exekveringen är igång?


\Task \label{task:java} \emph{Java-applikation.} Skapa med hjälp av en editor en fil med namn \texttt{Hi.java}.
\begin{REPL}
> gedit Hi.java
\end{REPL}
Skriv dessa rader i filen:

\javainputlisting{examples/Hi.java}

\noindent Kompilera med \code{javac Hi.java} och kör koden med \code{java Hi}.
\begin{REPL}
> javac Hi.java
> ls
> java Hi
\end{REPL}

\Subtask\Pen Vad heter filen som kompilatorn skapat?

\Subtask\Pen Jämför signaturen för Java-programmets main-metod med signaturen för Scala-programmets main-metod. De betyder samma sak men syntaxen är olika. Beskriv skillnader och likheter i syntaxen.

\Subtask\Pen Vad blir det för felmeddelande om källkodsfilen och klassnamnet inte överensstämmer?


\Task \emph{Algoritm: SUM}. Nedan återfinns pseudo-koden för SUM. 

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}
 
 \Input{heltalet $n$}
 \Output{utskrift av summan av de första $n$ heltalen }
 $sum \leftarrow 0$ \\
 $i \leftarrow 1$  \\
 \While{$i <= n$}{
  $sum \leftarrow sum + 1$
 }
 skriv ut $sum$
\end{algorithm}

\Subtask\Pen Det finns en bugg i pseudokoden. Vilken? Rätta buggen.

\Subtask Skapa med hjälp av en editor filen \code{sumn.scala}. Implementera algoritmen enligt den rättade pseudokoden och placera implementationen i en main-metod i ett objekt med namnet \code{sumn}. Du kan skapa indata till algoritmen med denna deklaration i början av din main-metod: \\ \code{val n = args(0).toInt} \\ Vad ger applikationen för utskrift om du kör den med argumentet 8888? 

\begin{REPL}
> scalac sumn.scala
> scala sumn 8888
\end{REPL}

\Subtask Kontrollera att din implementation räknar rätt genom att jämföra svaret med detta uttrycks värde, evaluerat i Scala REPL:
\begin{REPL}
scala> (1 to 8888).sum
\end{REPL}

\Subtask Implementera algoritmen SUM enligt pseudokoden ovan, men nu i Java. Skapa filen \code{SumN.java} och använd koden från uppgift \ref{task:java} som mall för att deklarera den publika klassen \code{SumN} med en main-metod. Några tips om Java-syntax och standarfunktioner i Java: 

\begin{itemize}[noitemsep, nolistsep]
\item Alla satser i Java måste avslutas med semikolon.
\item Heltalsvariabler deklareras med nyckelordet \lstinline[language=Java]{int} (litet i). 
\item Typnamnet ska stå \emph{före} namnet på variabeln. Exempel: \\ \lstinline[language=Java]{int sum = 0;}
\item Indexering i en array görs i Java med hakparenteser: \code{args[0]}
\item I stället för Scala-koden \code{args(0).toInt}, använd uttrycket \\ \code{Integer.parseInt(args[0])}
\item \code{while}-satser i Scala och Java har samma syntax.
\item Utskrift i Java görs med \code{System.out.println}
\end{itemize}


\Task \emph{Algoritm: MAX}. Nedan återfinns pseudo-koden för MAX. 

\begin{algorithm}[H]
 \SetKwInOut{Input}{Indata}\SetKwInOut{Output}{Resultat}
 
 \Input{Array $args$ med strängar som alla innehåller heltal}
 \Output{utskrift av största heltalet }
 $max \leftarrow$ det minsta heltalet som kan uppkomma  \\
 $n \leftarrow $ antalet heltal \\
 $i \leftarrow 0$ \\
 \While{$i < n$}{
   $x \leftarrow args(i).toInt$ \\
   \If{( x > $max$)}{$max \leftarrow x$} 
  % $i \leftarrow i + 1$
 }
 skriv ut $max$
\end{algorithm}

\Subtask\Pen Det finns en bugg i pseudokoden. Vilken? Rätta buggen.

\Subtask Implementera algoritmen ovan i en Scala-applikation. Tips:
\begin{itemize}[noitemsep, nolistsep]
\item Det minsta heltalet som någonsin kan uppkomma: \code{Int.MinValue}
\item Antalet element i $args$ ges av: \code{args.size}
\end{itemize}

\begin{REPL}
> gedit maxn.scala
> scalac maxn.scala
> scala maxn 7 42 1 -5 9
42
\end{REPL}

\Subtask\Pen \label{subtask:arg0} Skriv om algoritmen så att variablen $max$ initialiseras med det första talet i sekvensen. 

\Subtask Implementera den nya algoritmvarianten från uppgift \ref{subtask:arg0} och prova programmet. Vad händer om $args$ är tom?

\Task \emph{Block, namnsynlighet, namnöverskuggning}

\Task \emph{Paket, \code{import} och klassfilstrukturer.}

\Task \emph{Skapa \code{jar}-filer och använda classpath}

\Task \emph{Skapa dokumentation med \code{scaladoc}-kommandot}


\ExtraTasks %%%%%%%%%%%%%%%%%%%

\Task 

\AdvancedTasks %%%%%%%%%%%%%%%%%

\Task ArrayBuffer vs Vector vs Array och metoden append

\Task Läs om krullparenetser och vanliga parenteser på stack overflow: \\ \href{http://stackoverflow.com/questions/4386127/what-is-the-formal-difference-in-scala-between-braces-and-parentheses-and-when}{what-is-the-formal-difference-in-scala-between-braces-and-parentheses-and-when}