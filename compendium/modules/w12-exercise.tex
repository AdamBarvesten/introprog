%!TEX encoding = UTF-8 Unicode

%!TEX root = ../compendium.tex

\Exercise{\ExeWeekTWELVE}

\begin{Goals}
\item Känna till vad en tråd är och kunna förklara begreppet jämlöpande exekvering.
\item Känna till vad metoderna \code{run} och \code{start} gör i klassen \code{Thread}.
\item Kunna skapa och starta en tråd med ölverskuggad \code{run}-metod.
\item Kunna skapa ett enkelt program som från två trådar tävlar om att uppdatera en variabel och förklara varför beteendet kan bli oförutsägbart.
\item Kunna använda en \code{Future} för att köra igång flera parallella beräkningar.
\item Kunna registrera en callback på en \code{Future} med metoden \code{onComplete}.
\item Känna till att webbsidor beskrivs av HTML-kod och kunna skapa en minimal webbsida.
\item Kunna ladda ner en webbsida med \code{scala.io.Source.fromURL}.
\end{Goals}

\begin{Preparations}
\item Studera teorin i kapitel \ref{chapter:W12}.
\end{Preparations}

\BasicTasks %%%%%%%%%%%%%%%%

\Task \emph{Trådar.}  Klassen \code{java.lang.Thread} används för att skapa  \textbf{trådar} med jämlöpande exekvering \Eng{concurrent execution}. På så sätt kan man få olika koddelar att köra samtidigt. 

Klassen \code{Thread} definierar en tom \code{run}-metod. Vill man att tråden ska göra något vettigt får man överskugga \code{run} med det man vill ska göras. 

En tråd körs igång med metoden \code{start} och då anropas automatiskt \code{run}-metoden och tråden exekverar koden i \code{run} jämlöpande med övriga trådar. Om man anropar \code{run} direkt blir det \emph{inte} jämlöpande exekvering. 

\Subtask Skapa en tråd som gör något som tar lite tid och kör med \code{run} resp. \code{start}.
\begin{REPL}
def zzz = { print("zzzzzz"); Thread.sleep(5000); println(" VAKEN!")}
zzz
val t2 = new Thread{ override def run = zzz }
t2.run
t2.run; println("Gomorron!")
t2.start; println("Gomorron!")
t2.start
\end{REPL}

\Subtask Vad händer om man anropar \code{start} mer än en gång på samma tråd?

\Subtask Skapa två trådar med överskuggade \code{run}-metoder och kör igång dem samtidigt enligt nedan. Vilken ordning skrivs hälsningarna ut efter rad 3 resp. rad 4 nedan? Förklara vad som händer.
\begin{REPL}
val g = new Thread{ override def run = for (i <- 1 to 100) print("Gurka ") }
val t = new Thread{ override def run = for (i <- 1 to 100) print("Tomat ") }
g.run; t.run
g.start; t.start
\end{REPL}

\Subtask Använd \code{Thread.sleep} enligt nedan. Är beteendet helt förutsägbart (deterministiskt)? Förklara vad som händer.
\begin{REPL}
def ibland(block: => Unit) = new Thread {
  override def run = while(true) { block; Thread.sleep(600) }
}.start
ibland(print("zzz ")); ibland(print("snark ")); ibland(println("hej!")) 
\end{REPL}


\Task \label{task:racecondition} \emph{Jämlöpande variabeluppdatering.} Skriv klasserna \code{Bank} och \code{Kund} i en editor och klistra sedan in koden i REPL.

\begin{Code}
class Bank { 
  private var saldo = 0;
  def visaSaldo: Unit = println(s"saldo: $saldo")
  def sättIn: Unit = { saldo += 1 } 
  def taUt: Unit   = { saldo -= 1 }
}

class Kund(bank: Bank) {
  def slösaSpara = {bank.taUt; Thread.sleep(1); bank.sättIn}
}
\end{Code}

\Subtask Använd funktionen \code{ibland} från föregående uppgift. Förklara vad som händer nedan.

\begin{REPL}
val bank = new Bank
bank.visaSaldo
bank.sättIn
bank.visaSaldo
bank.taUt
bank.visaSaldo

val bamse = new Kund(bank)
val skutt = new Kund(bank)

bamse.sparaSlösa
skutt.sparaSlösa
bank.visaSaldo

def ofta(block: => Unit) = new Thread {
  override def run = while(true) { block; Thread.sleep(1) }
}.start

ofta(bamse.slösaSpara); ofta(skutt.slösaSpara)

ibland(bank.visaSaldo)
\end{REPL}


\Task \emph{Jämlöpande exekvering med \code{scala.concurrent.Future}.} Att hålla reda på trådar kan bli ganska knepigt. Med hjälp av \code{scala.concurrent.Future} kan man sätta igåg beräkningar i nya trådar och sedan köra vidare med annat. 

\begin{Background}
Med en \code{Future} skapas jämlöpande exekvering som ''under huven'' använder ett avancerat ramverk som heter Akka\footnote{\url{http://akka.io/}}, skrivet i Scala och Java. Akka erbjuder automatisk  multitrådning med s.k. trådpooler och möjliggör avancerad parallellprogrammering på en hög  abstraktionsnivån, där man själv slipper att skapa instanser av klassen \code{Thread}. 
\end{Background}

I denna uppgift ska du ladda ner webbsidor parallellt med hjälp \code{Future} så att en nedladdning kan avslutas under tiden en annan dröjer.  

\Subtask Koden för en minimal webbsida ser ut som nedan. Du kan beskåda sidan här: \url{http://fileadmin.cs.lth.se/pgk/mini.html} eller skriva in nedan kod i en fil som heter något som slutar på \texttt{.html} och öppna filen i din webbläsare.

\begin{verbatim}
<!DOCTYPE html>
<html>
<body>
HELLO WORLD!
</body>
</html>
\end{verbatim}

\Subtask För att simulera slöa webbservrar kan man ladda ner en sida via sajten \texttt{http://deelay.me/}. Ladda ner ovan sida med 2 sekunders fördröjning:\\
\url{http://deelay.me/2000/http://fileadmin.cs.lth.se/pgk/mini.html}

\Subtask Man kan ladda ner webbsidor med \code{scala.io.Source}. Vad händer nedan? Hur lång tid måste du i medeltal, bästa fall respektive värsta fall vänta innan du kan se första webbsidan i vektorn \code{laddningar} nedan?

\begin{REPL}
scala> def ladda(url: String) = scala.io.Source.fromURL(url).getLines.toVector
scala> def slöladda(url: String) = {
         val delay = (math.random * 1000 + 2000).toInt 
         val delaySite = s"http://deelay.me/$delay/"
         ladda(delaySite+url)
      }
scala> ladda("http://fileadmin.cs.lth.se/pgk/mini.html")
scala> def seg = slöladda("http://fileadmin.cs.lth.se/pgk/mini.html")
scala> val laddningar = Vector.fill(10)(seg)
scala> laddningar(0)
\end{REPL}

\Subtask Innan vi kan köra igång en \code{Future} så måste vi importera den underliggande exekveringsmiljön som är redo att parallelisera ditt program i trådar utan att du själv måste skapa dem. Detta görs med nedan import-satser. Förklara vad som händer nedan.
\begin{REPL}
scala> import scala.concurrent._ 
scala> import ExecutionContext.Implicits.global
scala> val f = Future{ seg }
scala> f   // kolla om den är klar annars prova igen senare
scala> f
\end{REPL}

\Subtask Ladda indata utan att blockera \Eng{non-blocking input}. Förklara vad som händer nedan.
\begin{REPL}
scala> val nonblock = Future{ Vector.fill(10)(seg) }
scala> nonblock   // kolla igen senare om ej klar
scala> nonblock  
\end{REPL}

\Subtask Ladda indata separat i olika parallella trådar. Förklara vad som händer nedan.
\begin{REPL}
scala> val para = Vector.fill(10)(Future{ seg })
scala> para
scala> para.map(_.isCompleted)   
scala> para.map(_.isCompleted) // studera hur de blir färdiga en efter en
scala> para(0)
\end{REPL}

\Subtask Registrera en s.k. \emph{callback} med metoden \code{onComplete}. Förklara vad som händer nedan.

\begin{REPL}
scala> val action = Vector.fill(10)(Future{ seg })
scala> action(0).onComplete(xs => println(s"ready:$xs"))
scala> // vänta tills laddning på plats 0 är klar
\end{REPL}


\ExtraTasks %%%%%%%%%%%%%%%%%%%
  
\Task TODO  Fråga Patrik Persson om ideer till enkla ''more-of-the-same'' som gör att man fattar vad en Future är och vad jämlöpande exekvering är om man nu tyckte grunduppgifterna var svåra. Kanske några enkla teorifrågor som skulle kunna komma på en tenta del 1? Typ: Vad är en tråd? Vad är en Future och vad är fördelen med att använda Future jämfört med att använda trådar direkt? Vilka svårigheter kan uppstå vid jämlöpande exekvering? Vad betyder ''trådsäker''? %%%%%%%%%%%%%%%%%%%

\AdvancedTasks %%%%%%%%%%%%%%%%%

\Task \emph{Skapa din egen multitrådade webbserver.} 

\Subtask Skriv in nedan\footnote{Koden är inspirerad av svaret på denna fråga: 
\href{http://stackoverflow.com/questions/1186328/embedded-http-server-in-swing-java-app}{http://stackoverflow.com/questions/1186328}} kod i en editor och spara i en fil med namn \texttt{webserver.scala} och kompilera och kör och beskriv vad som händer när du med din webbläsare surfar till adressen: \url{http://localhost:8080/akrug}

\scalainputlisting[numbers=left,basicstyle=\ttfamily\fontsize{11}{12}\selectfont]{examples/webserver.scala}

\Subtask Vad händer om du surfar till \url{http://localhost:8080/killserver} efter att du startat din webbserver?

\Subtask Skapa en \code{HttpHandler} som heter \code{FibHandler} som, om du surfar till  \url{http://localhost:8080/fib/13}, svarar med det 13:e Fibbonnaci-talet\footnote{\href{https://sv.wikipedia.org/wiki/Fibonaccital}{https://sv.wikipedia.org/wiki/Fibonaccital}} enligt nedan. Säkerställ med hjälp av \code{scala.util.Try} att din server inte kraschar om man skriver något annat än ett heltal efter \texttt{fib/} i addressfältet i browsern.

\begin{Code}
class FibHandler extends HttpHandler {
  def fib(n: BigInt): BigInt = {
    if (n < 0) 0 else 
    if (n == 1 || n == 2) 1  
    else fib(n - 1) + fib(n -2)
  }
  
  def handle(exchange: HttpExchange ): Unit = ???
}
\end{Code} 

\scalainputlisting[numbers=left,basicstyle=\ttfamily\fontsize{11}{12}\selectfont]{examples/fibserver.scala}

\Subtask Surfa efter flera stora Fibonacci-tal samtidigt. Hur märks det att servern är multitrådad?

\Subtask Det är onödigt att räkna ut samma Fibonacci-tal flera gånger. Med hjälp av en cache i form av en föränderlig \code{Map} kan vi spara undan redan uträknade värden. Det funkar dock inte med en vanlig \code{scala.collection.mutable.Map} om vi ska anvnda den i vår multitrådade webbserver, eftersom den inte är trådsäker och det kan bli samma konstiga fenomen som i uppgift \ref{task:racecondition}. 

Vi kan i stället använda den trådsäkra \code{java.util.concurrent.ConcurrentHashMap} enligt nedan. Sök upp och studera dokumentationen för \code{ConcurrentHashMap}. Hur fungerar metoderna \code{containsKey}, \code{put} och \code{get}?
\begin{Code}
object fib {
  import java.util.concurrent.ConcurrentHashMap
  val memcache = new ConcurrentHashMap[BigInt, BigInt]
  
  def apply(n: BigInt): BigInt = 
    if (memcache.containsKey(n)) { 
      println("CACHE HIT!!! FOUND: " + n)
      memcache.get(n)
    } else {
      println("cache miss :( could not find: " + n)
      val f = fastFib(n)
      memcache.put(n, f)
      f
    }
  
  private def fastFib(n: BigInt): BigInt = {
    if (n < 0) 0 else 
    if (n == 1 || n == 2) 1  
    else apply(n - 1) + apply(n -2)
  }
}
\end{Code}
 
\Subtask Använd ovan \code{fib}-objekt i din webserver och undersök hur snabbt det nu går med stora Fibonacci-tal. Hur stora tal kan du räkna ut utan att det blir stack overflow? Klarar din server kraschen?

\Subtask Skriv om \code{fastFib} så att den använder en \code{while}-sats i stället för ett rekursivt anrop. Hur stora tal klarar den nu? Vad händer med servern när minnet tar slut? Hur kan du skydda servern så att den inte går att få att hänga?

\scalainputlisting[,basicstyle=\ttfamily\fontsize{11}{12}\selectfont]{examples/fastfib-memcache-while.scala}

\Task Lär dig mer om HTML här: \url{http://www.w3schools.com/html/}

\Task Scala.JS???


\Task Läs mer om \code{Future} och jämlöpande exekvering i Scala här:\\
\href{http://alvinalexander.com/scala/future-example-scala-cookbook-oncomplete-callback}{alvinalexander.com/scala/future-example-scala-cookbook-oncomplete-callback}

\Task Läs mer om jämlöpande exekvering och multitrådade program i Java här: \href{http://www.tutorialspoint.com/java/java_multithreading.htm}{www.tutorialspoint.com/java/java\_multithreading.htm}  \\
\noindent När man skriver program med jämlöpande exekvering finns det många fallgropar; det kan bli kapplöpning \Eng{race conditions} om gemensamma resurser och dödläge \Eng{deadlock} där inget händer får att trådar väntar på varandra. Mer om detta i senare kurser. 

