%!TEX encoding = UTF-8 Unicode

%!TEX root = ../compendium.tex

\Exercise{\ExeWeekNINE}

\begin{Goals}
\item 
\end{Goals}

\begin{Preparations}
\item 
\end{Preparations}

\BasicTasks %%%%%%%%%%%%%%%%

\Task \emph{Skapa matriser med hjälp av nästlade samlingar.} Man kan i ett datorprogram, med hjälp av samlingar som innehåller samlingar, skapa nästlade strukturer som kan indexeras i två dimensioner och på så sätt representera en matematisk \textbf{matris}.\footnote{\href{https://sv.wikipedia.org/wiki/Matris}{sv.wikipedia.org/wiki/Matris}} 
\begin{Background}
En \textbf{matris} inom matematiken innehåller ett antal rader och kolumner (även kallade kolonner). I en matematisk matris har alla rader lika många element och även alla kolumner har lika många element. En matris av dimension $m\times{}n$ har $m \cdot n$ stycken element, där $m$ är antalet rader och $n$ är antalet kolumner. En matris $A_{m,n}$ av dimension $m\times{}n$ ritas ofta så här:

\[
A_{m,n} = 
 \begin{pmatrix}
  a_{1,1} & a_{1,2} & \cdots & a_{1,n} \\
  a_{2,1} & a_{2,2} & \cdots & a_{2,n} \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  a_{m,1} & a_{m,2} & \cdots & a_{m,n} 
 \end{pmatrix}
\]

\noindent Exempel: En heltalsmatris $M_{2,5}$ av dimension $2\times{}5$ där element $m_{2,5}=7$:

\[
M=
  \begin{pmatrix}
    5 & 2 & 42 & 4 & 5 \\
    3 & 4 & 18 & 6 & 7
  \end{pmatrix}
\]
\end{Background}

\Subtask\Pen Rita minnessituationen efter tilldelningen på rad 1 nedan. Vad har \code{m} för typ och värde? Vad har \code{m} för dimensioner? Hur sker indexeringen i ett datorprogram jämfört med i matematiken?

\begin{REPL}
scala> val m = Vector((1 to 5).toVector, (3 to 7).toVector)
scala> m.apply(0).apply(1)
scala> m(1)
scala> m(1)(4)
\end{REPL}

\Subtask Vad ger uttrycken på raderna 2, 3 och 4 ovan för värden och typ? 

\Subtask Man kan i ett datorprogram mycket väl skapa tvådimensionella, nästlade strukturer där raderna innehåller olika antal element. Det blir då ingen äkta matris i strikt matematisk mening, men man kallar ofta ändå en sådan struktur för en ''matris''. Vilken typ har variablerna \code{m2}, \code{m3}, \code{m4} och \code{m5} nedan? 

\begin{REPL}
scala> val m2 = Vector(Vector(1,2,3),Vector(4,5),Vector(42))
scala> val m3 = Vector(Vector(1,2), Vector(1.0, 2.0, 3.0))
scala> m3(1)
scala> val m4 = m3(1) +: Vector("a") +: m3
scala> val m5 = Vector.fill(42){ m2(1).map(e => (e * math.random).toInt) }
\end{REPL}

\Subtask\Pen Rita minnessituationen efter tilldelingen av \code{m2} på rad 1 ovan.

\Subtask\Pen Vilken av variablerna \code{m2}, \code{m3}, \code{m4} och \code{m5} ovan representerar en äkta matris i matematisk mening? Vilken är dess dimensioner?



\Task \emph{Skapa och itererar över matriser.} Vi ska skapa matriser där varje rad representerar 5 tärningskast i spelet Yatzy.\footnote{\href{https://sv.wikipedia.org/wiki/Yatzy}{sv.wikipedia.org/wiki/Yatzy}}


\Subtask Definiera i REPL en funktion \code{def throwDie: Int = ???} som returnerar ett slumptal mellan 1 och 6.
\begin{Code}
// kod till facit
def throwDie: Int = (math.random * 6).toInt + 1
\end{Code}

\Subtask Definera i REPL en funktion \code{isYatzy(xs: Vector[Int]): Boolean = ???} som testar om alla elementen i en heltalsvektor är samma. 
\begin{Code}
// kod till facit
def isYatzy(xs: Vector[Int]): Boolean = xs.forall(_ == xs(0))
\end{Code}


\Subtask Skapa nedan heltalsmatris i REPL. Vilken dimension får matrisen?
\begin{REPL}
val ds1 = for (i <- 1 to 1000) yield { 
            for (j <- 1 to 5) yield throwDie 
          }
\end{REPL}

\Subtask Man kan också använda nedan varianter för att skapa en heltalsmatris. Vilken variant av \code{ds1} ... \code{ds4} ger den mest specifika typen?  
\begin{REPL}
val ds2 = (1 to 1000).map(i => (1 to 5).map(j => throwDie))  
val ds3 = (1 to 1000).map(i => Vector.fill(5)(throwDie)) 
val ds4 = for (i <- 1 to 1000) yield Vector.fill(5)(throwDie) 
val ds5 = Vector.fill(1000)(Vector.fill(5)(throwDie))
\end{REPL}

\Subtask\Pen Vilken variant ovan tycker du är lättast att läsa och förstå?

\Subtask Skriv en funktion \code{def throwDices(n: Int): Vector[Int] = ???} som ger en heltalsvektor med \code{n} st slumpvisa tärningskast. 
\begin{Code}
// kod till facit
def throwDices(n: Int): Vector[Int] = Vector.fill(n)(throwDie)
\end{Code}

\Subtask Deklarera nedan typ-alias. Nämn några fördelar med att använda typ-alias?
\begin{REPL}
scala> type DiceMat = Vector[Vector[Int]]
\end{REPL}
{\color{red}{TODO: Till facit: (1) Slipper skriva långa typer (2) kan lätt ändra typ senare genom att bara äåndra på ett ställe (3) Koden blir lättare att begripa då typnamnet kan hjälpa till att beskriva vad typen används till på samma sätt som en klass, men man behöver inte skapa en klass -- det kan göras senare om behov uppstår.}}


\Subtask Skapa en funktion \code{def yatzyMatrix(m: Int): DiceMat = ???} som med hjälp av funktionen \code{throwDices} skapar en matris med \code{n} st vektorer med vardera 5 slumpvisa tärningskast.
\begin{Code}
// kod till facit
def yatzyMatrix(m: Int): DiceMat = Vector.fill(m)(throwDices(5))
\end{Code}

\Subtask Skapa en funktion \code{def matrixToString(xss: Vector[Vector[Int]]): String = ???} som ger följande utskrift om den skriver ut de slumpvisa tärningskasten enligt nedan format. 
\begin{REPL}
scala> println(matrixToString(yatzyMatrix(10)))
4 5 5 3 3
1 4 1 3 1
1 3 1 5 5
6 4 4 5 5
2 1 5 6 5
1 2 2 3 6
1 3 2 4 5
2 2 3 2 2
2 6 3 4 6
4 5 5 2 3

\end{REPL}
Ett krångligt sätt att göra detta visas nedan. Förklara hur nedan kod fungerar. Använd sedan istället ett enklare sätt med hjälp av \code{map} och \code{mkString}.
\begin{REPL}
def matrixToString(xss: Vector[Vector[Int]]): String = {
  val sb = new StringBuilder()
  for(m <- 0 until xss.size) {
    for(n <- 0 until xss(m).size) { 
      sb.append(xss(m)(n))
      if (n < xss(m).size - 1) sb.append(" ") 
      else if (m < xss.size - 1) sb.append("\n")
    }
  }
  sb.toString
}
\end{REPL}

 
\begin{Code}
// kod till facit
def matrixToString(xss: Vector[Vector[Int]]): String = 
  xss.map(_.mkString(" ")).mkString("\n")
\end{Code}


\Subtask Skapa med en editor ett objekt enligt nedan specifikation. 

\begin{ScalaSpec}{object yatzy}
/** */
object yatzy {
  type IntMat = Vector[Vector[Int]]
}
\end{ScalaSpec}


\Task \emph{case class StringMatix with heading using Vector[Vector[String]]}


\Task \emph{Dense Matrix of Double using private Array[Double]}

\Task \emph{Sparse Matrix of Double using private mutable.Map[(Int, Int), Double]}




\Task \emph{Matriser i Java.}





\Task \emph{Generiska klasser.} 

\begin{REPL}
scala> class Cell[T](var value: T){
         override def toString = "Cell(" + value + ")"
       }
scala> val c = new Cell(42)
\end{REPL}

\Subtask Lägg till en metod \code{def concat[U](that: Cell[U]):Cell[String]} i klassen \code{Cell} som konkatenerar strängrepresentationerna av de båda cellvärdena.

\begin{REPL}
scala> val a = new Cell("hej")
scala> val b = new Cell(42)
scala> a concat b
\end{REPL}

\begin{Code}
// kod till facit
class Cell[T](var value: T){
  override def toString = "Cell(" + value + ")"
  def concat[U](that: Cell[U]): Cell[String] = 
    new Cell[String](value.toString + that.value.toString)
}
\end{Code}

\Subtask\Pen Vad händer om du i stället för typparameternamnet \code{U} i \code{concat} använder namnet \code{T}?

\Task \emph{Skapa en generisk, ofäränderlig matrisklass.}

\begin{Code}
case class Matrix[T](data: Vector[Vector[T]]) {
  def apply(x: Int, y: Int): T = ???
  def get(x: Int, y: Int): Option[T] = ???
  def row(r: Int): Vector[T] = ???
  def col(c: Int): Vector[T] = ???
  def updated(x: Int, y: Int, value: T): Matrix[T] = ???
}
object Matrix {
  def empty[T]: Matrix[T] = new Matrix[T](Vector())
  def ofRowSize[T](rowSize: Int)(elements: T*): Matrix[T] =
    new Matrix(elements.toVector.grouped(rowSize).toVector)
}
\end{Code}

\Subtask 

\ExtraTasks %%%%%%%%%%%%%%%%%%%

\Task Skapa en oföränderlig, final klass \code{Mat} för matematiska matriser och en oföränderlig, final klass \code{Vec} för matematiska vektorer. \code{Mat} ska internt lagra elementen i en privat endimensionell array av flyttal av typen \code{Float}. Klasserna ska inte vara case-klasser, men det ska ändå gå att skapa matriser med uttrycket Mat.ofDim(3,7)(1.0,42,3.2,1.0,2.2,3) tack vare  kompanjonsobjekt med lämpliga fabriksmetoder. TODO etc etc.

\Subtask Överskugga metoden equals och ge klasserna \code{Mat} och \code{Vec} innehållslikhet i stället för referenslikhet när \code{==} anropas.

\Subtask Implementera egna innehålllikhetsmetoder med namnet \code{===} på både \code{Mat} och \code {Vec} som är typsäkra, d.v.s. bara tillåter jämförelse mellan matriser, resp. vektorer.

\AdvancedTasks %%%%%%%%%%%%%%%%%

\Task     
    