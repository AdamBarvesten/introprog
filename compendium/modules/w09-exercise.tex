%!TEX encoding = UTF-8 Unicode

%!TEX root = ../compendium.tex

\Exercise{\ExeWeekNINE}

\begin{Goals}
\item 
\end{Goals}

\begin{Preparations}
\item 
\end{Preparations}

\BasicTasks %%%%%%%%%%%%%%%%

\Task \emph{Skapa matriser med hjälp av nästlade samlingar.} Man kan i ett datorprogram, med hjälp av samlingar som innehåller samlingar, skapa nästlade strukturer som kan indexeras i två dimensioner och på så sätt representera en matematisk \textbf{matris}.\footnote{\href{https://sv.wikipedia.org/wiki/Matris}{sv.wikipedia.org/wiki/Matris}} 
\begin{Background}
En \textbf{matris} inom matematiken innehåller ett antal rader och kolumner (även kallade kolonner). I en matematisk matris har alla rader lika många element och även alla kolumner har lika många element. En matris av dimension $m\times{}n$ har $m \cdot n$ stycken element, där $m$ är antalet rader och $n$ är antalet kolumner. En matris $A_{m,n}$ av dimension $m\times{}n$ ritas ofta så här:

\[
A_{m,n} = 
 \begin{pmatrix}
  a_{1,1} & a_{1,2} & \cdots & a_{1,n} \\
  a_{2,1} & a_{2,2} & \cdots & a_{2,n} \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  a_{m,1} & a_{m,2} & \cdots & a_{m,n} 
 \end{pmatrix}
\]

\noindent Exempel: En heltalsmatris $M_{2,5}$ av dimension $2\times{}5$ där element $m_{2,5}=7$:

\[
M=
  \begin{pmatrix}
    5 & 2 & 42 & 4 & 5 \\
    3 & 4 & 18 & 6 & 7
  \end{pmatrix}
\]
\end{Background}

\Subtask\Pen Rita minnessituationen efter tilldelningen på rad 1 nedan. Vad har \code{m} för typ och värde? Vad har \code{m} för dimensioner? Hur sker indexeringen i ett datorprogram jämfört med i matematiken?

\begin{REPL}
scala> val m = Vector((1 to 5).toVector, (3 to 7).toVector)
scala> m.apply(0).apply(1)
scala> m(1)
scala> m(1)(4)
\end{REPL}

\Subtask Vad ger uttrycken på raderna 2, 3 och 4 ovan för värden och typ? 

\Subtask Man kan i ett datorprogram mycket väl skapa tvådimensionella, nästlade strukturer där raderna \emph{inte} innehåller samma antal element. Det blir då ingen äkta matris i strikt matematisk mening, men man kallar ofta ändå en sådan struktur för en ''matris''. Vilken typ har variablerna \code{m2}, \code{m3}, \code{m4} och \code{m5} nedan? 

\begin{REPL}
scala> val m2 = Vector(Vector(1,2,3),Vector(4,5),Vector(42))
scala> val m3 = Vector(Vector(1,2), Vector(1.0, 2.0, 3.0))
scala> m3(1)
scala> val m4 = m3(1) +: Vector("a") +: m3
scala> val m5 = Vector.fill(42){ m2(1).map(e => (e * math.random).toInt) }
\end{REPL}

\Subtask\Pen Rita minnessituationen efter tilldelingen av \code{m2} på rad 1 ovan.

\Subtask\Pen Vilken av variablerna \code{m2}, \code{m3}, \code{m4} och \code{m5} ovan representerar en äkta matris i matematisk mening? Vilken är dess dimensioner?



\Task \emph{Skapa och itererar över matriser.} Vi ska skapa matriser där varje rad representerar 5 kast med en tärning \Eng{dice} i spelet Yatzy.\footnote{\href{https://sv.wikipedia.org/wiki/Yatzy}{sv.wikipedia.org/wiki/Yatzy}}


\Subtask Definiera i REPL en funktion \code{def throwDice: Int = ???} som returnerar ett slumptal mellan 1 och 6.
\begin{Code}
// kod till facit
def throwDice: Int = (math.random * 6).toInt + 1
\end{Code}


\Subtask Skapa nedan heltalsmatris i REPL. Vilken dimension får matrisen?
\begin{REPL}
val ds1 = for (i <- 1 to 1000) yield { 
            for (j <- 1 to 5) yield throwDice 
          }
\end{REPL}

\Subtask\Pen Man kan också använda nedan varianter för att skapa en heltalsmatris. Vilken av varianterna \code{ds1} ... \code{ds5} tycker du är lättast att läsa och förstå? Prova respektive variant i REPL och ange vilken typ på \code{ds1} ... \code{ds5} som härleds av kompilatorn.
\begin{REPL}
val ds2 = (1 to 1000).map(i => (1 to 5).map(j => throwDice))  
val ds3 = (1 to 1000).map(i => Vector.fill(5)(throwDice)) 
val ds4 = for (i <- 1 to 1000) yield Vector.fill(5)(throwDice) 
val ds5 = Vector.fill(1000)(Vector.fill(5)(throwDice))
\end{REPL}


\Subtask Definiera en funktion \\ \code{def throw(n: Int): Vector[Int] = ???}\\ som ger en heltalsvektor med $n$ stycken slumpvisa tärningskast. Kasten ska vara sorterade i växande ordning; använd för detta ändamål samlingsmetoden \code{sorted}.
\begin{Code}
// kod till facit
def throw(n: Int) = Vector.fill(n)(throwDice).sorted
\end{Code}


\Subtask Definera i REPL en funktion \code{isYatzy(xs: Vector[Int]): Boolean = ???} som testar om alla elementen i en heltalsvektor är samma. Använd samlingsmetoden \code{forall}. 
\begin{Code}
// kod till facit
def isYatzy(xs: Vector[Int]): Boolean = xs.forall(_ == xs(0))
\end{Code}

\Subtask Implementera \code{isYatzy} igen med ett imperativt angreppssätt som använder en \code{while}-sats (alltså utan att använda funktionella  \code{forall}). Ta hjälp av en variabel \code{i} som håller reda på index och en variabel \code{foundDiff} som håller reda på om ett avvikande värde upptäcks. Funktionen blir ca 10 rader, så det kan vara lämpligt att öppna en editor att skriva i medan du klurar ut lösningen. Prova genom att klistra in i REPL. 
\begin{Code}
// kod till facit
def isYatzy(xs: Vector[Int]): Boolean = {
  var foundDiff = false
  var i = 0
  while (i < xs.size  && !foundDiff){
    foundDiff = xs(i) != xs(0)
    i += 1
  } 
  !foundDiff
}
\end{Code}


\Subtask Skapa en funktion  \\ \code{def diceMatrix(m: Int, n: Int): Vector[Vector[Int]] = ???} \\ som med hjälp av funktionen \code{throw} skapar en matris med \code{m} st vektorer med vardera \code{n} slumpvisa tärningskast.
\begin{Code}
// kod till facit
def diceMatrix(m: Int, n: Int): Vector[Vector[Int]] = 
  Vector.fill(m)(throw(n))
\end{Code}

\Subtask Skapa en funktion som returnerar en utskriftsvänlig sträng \\ \code{def diceMatrixToString(xss: Vector[Vector[Int]]): String = ???} \\med hjälp av \code{map} och \code{mkString}, som fungerar enligt nedan. 
\begin{REPL}
scala> println(diceMatrixToString(diceMatrix(10, 5)))
4 5 5 3 3
1 4 1 3 1
1 3 1 5 5
6 4 4 5 5
2 1 5 6 5
1 2 2 3 6
1 3 2 4 5
2 2 3 2 2
2 6 3 4 6
4 5 5 2 3

\end{REPL}
\begin{Code}
// kod till facit
def diceMatrixToString(xss: Vector[Vector[Int]]): String = 
  xss.map(_.mkString(" ")).mkString("\n")
\end{Code}


\Subtask\Pen Ett imperativt sätt\footnote{Detta anreppssätt är bra att kunna när du stöter på samlingar och/eller språk som saknar funktionsprogrammeringsmöjligheter med \code{map}, \code{mkString} etc.} att göra detta på visas nedan. Förklara hur nedan kod fungerar. Vad händer om \code{xss} är tom? Vad händer om \code{xss} bara innehåller tomma vektorer? Nämn en fördel och en nackdel med att använda \code{val sb: StringBuilder} och \code{append}, jämfört med en vanlig \code{var s: String} och \code{+} för tillägg i slutet.
\begin{Code}
def diceMatrixToString(xss: Vector[Vector[Int]]): String = {
  val sb = new StringBuilder()
  for(m <- 0 until xss.size) {
    for(n <- 0 until xss(m).size) { 
      sb.append(xss(m)(n))
      if (n < xss(m).size - 1) sb.append(" ") 
      else if (m < xss.size - 1) sb.append("\n")
    }
  }
  sb.toString
}
\end{Code}

\Subtask Implementera funktionen \\ \code{def filterYatzy(xss: Vector[Vector[Int]]): Vector[Vector[Int]]} \\ som filtrerar fram alla yatzy-rader i matrisen \code{xss} enligt nedan. Använd din funktion \code{isYatzy} och samlingsmetoden \code{filter}. 
\begin{REPL}
scala> println(diceMatrixToString(filterYatzy(diceMatrix(10000, 5))))
2 2 2 2 2
3 3 3 3 3
1 1 1 1 1
3 3 3 3 3
4 4 4 4 4
6 6 6 6 6
2 2 2 2 2
3 3 3 3 3
2 2 2 2 2
6 6 6 6 6
4 4 4 4 4
2 2 2 2 2
4 4 4 4 4

\end{REPL}

\begin{Code}
// kod till facit
def filterYatzy(xss: Vector[Vector[Int]]): Vector[Vector[Int]] = 
  xss.filter(isYatzy)
\end{Code}

\Subtask Gör som träning en imperativ implementation av \code{filterYatzy} med en \code{for}-sats (alltså utan att använda \code{filter}, och utan att använda \code{yield}). 
\begin{CodeSmall}
// kod till facit
def filterYatzy(xss: Vector[Vector[Int]]): Vector[Vector[Int]] = {
  var result: Vector[Vector[Int]] = Vector()
  for (i <- 0 until xss.size) {
    if (isYatzy(xss(i))) result = result :+ xss(i) 
  } 
  result
}
\end{CodeSmall}

\Subtask\Pen Tycker du din imperativa lösning är lättare eller svårare att läsa och förstå jämfört nedan funktionella lösning med ett \code{for}-uttryck och \code{yield}?
\begin{CodeSmall}
def filterYatzy(xss: Vector[Vector[Int]]): Vector[Vector[Int]] = {
  for (i <- 0 until xss.size if isYatzy(xss(i))) yield xss(i)
}.toVector  
\end{CodeSmall}

\Subtask Implementera funktionen \\ 
\code{def yatzyPips(xss: Vector[Vector[Int]]): Vector[Int]} \\ som ger en vektor med tärningsvärdena för de kast i matrisen \code{xss} som gav yatzy enligt nedan. Använd din funktion \code{isYatzy} och samlingsmetoden \code{filter}. 
\begin{REPL}
scala> yatzyPips(diceMatrix(10000, 5))
res42: Vector[Int] = Vector(3, 5, 6, 6, 3, 3, 2, 6, 1, 3)
\end{REPL}

\begin{Code}
// kod till facit
def yatzyPips(xss: Vector[Vector[Int]]): Vector[Int] = 
  xss.filter(isYatzy).map(_.head)
\end{Code}



\Task \emph{Strängtabell med rubrikrad.} Denna övning utgör en början på det du ska göra under veckans laboration.

\Subtask Implementera case-klassen \code{Table} enligt nedan specifikation. Du kan förutsätta att alla rader har lika många kolumner som antalet element i \code{headings}, samt att alla rubrikerna i \code{headings} är unika. Detta förutsätts också gälla för indatafiler som läses in med \code{fromFile}. 
\\ \noindent \emph{Tips:} 
\begin{itemize}[nolistsep,noitemsep]
\item Värdet \code{indexOfHeading} skapas lättas med hjälp av metoden \code{zipWithIndex} som fungerar på alla sekvenssamlingar.
\item Skapa en indatafil som du kan använda för att testa att \code{Table} fungerar. 
\end{itemize}

\begin{ScalaSpec}{Table}
case class Table(
  data: Vector[Vector[String]], 
  headings: Vector[String], 
  sep: String){
  /** A 2-tuple with (number of rows, number of columns) in data */
  val dim: (Int, Int) = ???

  /** The element in row r an column c of data, counting from 0 */
  def apply(r: Int, c: Int): String = ???

  /** The row-vector r in data, counting from 0 */
  def row(r: Int): Vector[String]= ???

  /** The column-vector c in data, counting from 0 */
  def col(c: Int): Vector[String] = ???

  /** A map from heading to index counting from 0 */
  lazy val indexOfHeading: Map[String, Int] = ???

  /** The column-vector with heading h in data */
  def col(h: String): Vector[String] = ???

  /** A vector with the distinct, sorted values of col with heading h */ 
  def values(h: String): Vector[String] = ???

  /** Headings and data with columns separated by sep */
  override lazy val toString: String = ???
}
case object Table {
  /** Creates a new Table from fileName with columns split by sep */
  def fromFile(fileName: String, separator: Char = ';'): Table = ???
}
\end{ScalaSpec}


\begin{CodeSmall}
// kod till facit

case class Table(
  data: Vector[Vector[String]], 
  headings: Vector[String], 
  sep: String){

  val dim: (Int, Int) = (data.size, headings.size)

  def apply(r: Int, c: Int): String = data(r)(c)

  def row(r: Int): Vector[String]= data(r)

  def col(c: Int): Vector[String] = data.map(r => r(c))

  lazy val indexOfHeading: Map[String, Int] = headings.zipWithIndex.toMap

  def col(h: String): Vector[String] = col(indexOfHeading(h)) 

  def values(h: String): Vector[String] = col(h).distinct.sorted

  override lazy val toString: String = 
    headings.mkString(sep) + "\n" +data.map(_.mkString(sep)).mkString("\n")
}
case object Table {
  def fromFile(fileName: String, separator: Char = ';'): Table = {
    val lines = scala.io.Source.fromFile(fileName).getLines.toVector
    val matrix= lines.map(_.split(separator).toVector) 
    new Table(matrix.tail, matrix.head, separator.toString)
  }
}
\end{CodeSmall}

\Subtask Skapa med hjälp av \code{Table} ett program som kan köras från terminalen med \texttt{scala regtable infile.csv ';'} som ger en utskrift av antalet förekomster av respektive unika värde i respektive kolumn (alltså en variant av registrering).



\Task \emph{En klass för matematiska matriser.}

\Subtask Skapa en oföränderlig, final klass \code{Mat} för matematiska matriser. \code{Mat} ska internt lagra elementen i en privat \emph{endimensionell} array av flyttal av typen \code{Array[Double]}. Klassen ska inte vara en case-klass. Det ska gå att skapa matriser med uttrycket Mat.ofDim(3,7)(1.0,42,3.2,1.0,2.2,3) tack vare  kompanjonsobjekt med lämpliga fabriksmetoder. 

\Subtask Överskugga metoden equals och ge klasserna \code{Mat} och \code{Vec} innehållslikhet i stället för referenslikhet när \code{==} anropas.

\Subtask Implementera egna innehålllikhetsmetoder med namnet \code{===} på \code{Mat} som är typsäker, d.v.s. bara tillåter jämförelse mellan matriser, resp. vektorer.


\Task \emph{Sparse Matrix of Float using private mutable.Map[(Int, Int), Double]}



\Task \emph{Matriser i Java.}





\Task \emph{Generiska klasser.} 

\begin{REPL}
scala> class Cell[T](var value: T){
         override def toString = "Cell(" + value + ")"
       }
scala> val c = new Cell(42)
\end{REPL}

\Subtask Lägg till en metod \code{def concat[U](that: Cell[U]):Cell[String]} i klassen \code{Cell} som konkatenerar strängrepresentationerna av de båda cellvärdena.

\begin{REPL}
scala> val a = new Cell("hej")
scala> val b = new Cell(42)
scala> a concat b
\end{REPL}

\begin{Code}
// kod till facit
class Cell[T](var value: T){
  override def toString = "Cell(" + value + ")"
  def concat[U](that: Cell[U]): Cell[String] = 
    new Cell[String](value.toString + that.value.toString)
}
\end{Code}

\Subtask\Pen Vad händer om du i stället för typparameternamnet \code{U} i \code{concat} använder namnet \code{T}?

\Task \emph{Skapa en generisk, ofäränderlig matrisklass.}

\begin{Code}
case class Matrix[T](data: Vector[Vector[T]]) {
  def apply(x: Int, y: Int): T = ???
  def get(x: Int, y: Int): Option[T] = ???
  def row(r: Int): Vector[T] = ???
  def col(c: Int): Vector[T] = ???
  def updated(x: Int, y: Int, value: T): Matrix[T] = ???
}
object Matrix {
  def empty[T]: Matrix[T] = new Matrix[T](Vector())
  def ofRowSize[T](rowSize: Int)(elements: T*): Matrix[T] =
    new Matrix(elements.toVector.grouped(rowSize).toVector)
}
\end{Code}

\Subtask 

\ExtraTasks %%%%%%%%%%%%%%%%%%%

\Task Skapa ett yatzy-spel i terminalen.

\Subtask Skapa med en editor ett objekt enligt nedan specifikation. Läs om hur de olika predikaten för att kolla olika giltiga kombinationer i Yatzy ska fungera här: \href{https://en.wikipedia.org/wiki/Yahtzee}{n.wikipedia.org/wiki/Yahtzee}. Bygg ett huvudprogram som testar dina funktioner. Kompilera och testa i terminalen allteftersom du lagger till nya funktioner enligt nedan deluppgifter.

\begin{ScalaSpec}{YatzyGame}
/** En skiss på en klass som kan användas för att göra ett yatzy-spel */
case class YatzyGame(val thrown: Vector[Vector[Int]]) {
  /** Creates a new YatzyGame with a new row of 5 dice appended to thrown  */
  def throw: YatzyGame = ???

  /** Creates a new YatzyGame with the indices of the last row re-thrown  */
  def throw(indices: Vector[Int]): YatzyGame = ???
}

object YatzyGame {
  def isYatzy(xs: Vector[Int]): Boolean = ???
  def isThreeOfAKind(xs: Vector[Int]): Boolean = ???
  def isFourOfAKind(xs: Vector[Int]): Boolean = ???
  def isFullHouse(xs: Vector[Int]): Boolean = ???
  def isSmallStraight(xs: Vector[Int]): Boolean = ???
  def isLargeStraight(xs: Vector[Int]): Boolean = ???
}
\end{ScalaSpec}


\Subtask Använd objektet för att med hjälp av många slumpmässiga utfall beräkna sannolikheter för några olika giltiga kombinationer. Använd, om du vill, möjligheten som reglerna ger att slå om tärningar i två yterliggare kast, där de tärningar som slås om väljs slumpmässigt.

\Subtask Bygg ett förenklat yazty-spel i terminalen där användaren kan bestämma vilka tärningar som ska slås om.



\AdvancedTasks %%%%%%%%%%%%%%%%%

\Task Skapa ett interface trait Matrix[T] med konkreta finala implementationer FloatMatrix och IntMatrix StringMatrix som implementerar interfacet. De konkreta klasserna ska ha privata konstruktorer så att fabriksobjekent i kompanjonsobjektet Matrix används för att skapa instanser.
    